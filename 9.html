<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Minecraft Terrain</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #87ceeb; }
        canvas { display: block; }
        .f3-line { margin-bottom: .2em; text-shadow: 0 0 10px #333; }
        .key { display: inline-block; border-radius: 4px; padding: .1em .5em; background-color:dimgrey; border: 2px solid #fff; }
        #f3-box { position: absolute; top: 10px; right: 10px; color: white; font-size: 16px; font-family: monospace; }
        #coords {white-space: pre-line; padding-top: 1em;}
        #loading { position: absolute; color: white; font-weight: bold; text-shadow: 0 0 10px #333; z-index: -1; font-family: 'Courier New', Courier, monospace; left: 50%; top: 50%; transform: translate(-50%, -50%);}
        #crosshair { position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); width: 4px; height: 4px; color: white; font-weight: bold; display: flex; align-items: center; justify-content: center; width: 2em; height: 2em; pointer-events: none; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.160.1/three.js" integrity="sha512-HCh7TuJvWZ35Ixo/afKeBRbAUtnqQWOrpw5Fs1bdWjWILg175hy9XRmuqG/vWyAqBKvUZStGMAsqKmYKqP91YQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r110/examples/js/controls/PointerLockControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/simplex-noise@2.4.0/simplex-noise.min.js"></script>
</head>
<body>

    <div id="loading">Loading...</div>
    <div id="crosshair">+</div>

    <div id="f3-box">
        <div class="f3-line"><strong class="key">F8</strong> random teleport</div>
        <div class="f3-line"><strong class="key">F4</strong> set home</div>
        <div class="f3-line"><strong class="key">F6</strong> return to home</div>
        <div class="f3-line"><strong class="key">G</strong> gamemode: <span id="gamemode"></span></div>
        <div id="coords"></div>
    </div>

    <script type="module">
        import Stats from 'https://cdnjs.cloudflare.com/ajax/libs/stats.js/r17/Stats.min.js'

        const stata = {
            resize: 0,
            new_array: 0,
            chunks: 0,
            chunk_inites: 0,
            meshes: 0,
        }
        class PlayerController {
            inventory = {
                current_block: blocks_palette.stone,
            }

            constructor(world, gravity = 9.8, inertia = 0.99, start_position) {
                this.world = world
                // Use Minecraft-like parameters internally instead of given gravity/inertia
                this.gravity = 20 // Strong gravity for fast falling, similar to MC feeling
                this.inertia = inertia // Used for slight horizontal friction if needed
                this.position = new THREE.Vector3(start_position.x, start_position.y, start_position.z)
                this.velocity = new THREE.Vector3(0, 0, 0)
                this.isGrounded = false
                this.jumpForce = 7 // Enough to jump about 1.25 blocks high with g=20
                this.mcMoveSpeed = 4.317 // Walking speed close to Minecraft (~4.317 m/s)
                this.margin = 0.2
                this.mcWaterSpeed = 2.2 // Slower horizontal speed in water
                this.inWater = false
            }

            update(elapsed_ms) {
                const elapsed_seconds = elapsed_ms / 1000

                const block_legs = this.world.getBlock(this.position.x, this.position.y, this.position.z)
                const block_below = this.world.getBlock(this.position.x, this.position.y - 0.5, this.position.z)
                this.isGrounded = block_below && !block_below.passable
                this.inWater = (block_legs && block_legs.id === blocks_palette.water.id)

                // Water behavior: if in water, pressing jump moves up slowly, otherwise you sink slowly
                if(this.inWater) {
                    // In water, gravity effect is weaker, player can slowly move upward if jump is pressed
                    if(move_up) {
                        // Pressing jump: move upward, but weaker than on land
                        this.velocity.y += this.gravity * elapsed_seconds * 0.4
                    } else {
                        // Not pressing jump: sink slowly
                        this.velocity.y -= this.gravity * elapsed_seconds * 0.2
                    }

                    // Limit vertical velocity in water
                    const max_water_vel = 1.5
                    if(this.velocity.y > max_water_vel) this.velocity.y = max_water_vel
                    if(this.velocity.y < -max_water_vel) this.velocity.y = -max_water_vel

                    // Apply "drag" in water to horizontal movement
                    this.velocity.x *= 0.8
                    this.velocity.z *= 0.8
                } else {
                    // On land: normal gravity
                    if (!this.isGrounded) {
                        this.velocity.y -= this.gravity * elapsed_seconds
                    } else {
                        if(this.velocity.y < 0) {
                            this.velocity.y = 0
                        }
                    }
                }

                // Determine forward and right directions based on camera orientation
                const forward = new THREE.Vector3()
                camera.getWorldDirection(forward)
                forward.y = 0
                forward.normalize()

                const right = new THREE.Vector3().crossVectors(new THREE.Vector3(0,1,0), forward).normalize()

                let moveDir = new THREE.Vector3()
                if (move_forward) moveDir.add(forward)
                if (move_backward) moveDir.sub(forward)
                if (move_left) moveDir.add(right)
                if (move_right) moveDir.sub(right)

                // Use different speed in water or on land
                const current_speed = this.inWater ? this.mcWaterSpeed : this.mcMoveSpeed

                if (moveDir.length() > 0) {
                    moveDir.normalize()
                    this.velocity.x = moveDir.x * current_speed
                    this.velocity.z = moveDir.z * current_speed
                } else {
                    // No input: apply friction-like damping
                    // Approximate friction similar to MC by using a factor each frame
                    const friction = Math.pow(0.8, elapsed_seconds * 20)
                    this.velocity.x *= friction
                    this.velocity.z *= friction
                }

                const new_pos = this.position.clone().addScaledVector(this.velocity, elapsed_seconds)

                // Check collision in X direction
                const block_at_new_pos_x = this.world.getBlock(
                    new_pos.x + Math.sign(this.velocity.x) * this.margin,
                    this.position.y,
                    this.position.z
                )
                if(!block_at_new_pos_x?.passable) {
                    this.velocity.x = 0
                    new_pos.x = this.position.x
                }

                // Check collision in Z direction
                const block_at_new_pos_z = this.world.getBlock(
                    this.position.x,
                    this.position.y,
                    new_pos.z + Math.sign(this.velocity.z) * this.margin
                )
                if(!block_at_new_pos_z?.passable) {
                    this.velocity.z = 0
                    new_pos.z = this.position.x
                    new_pos.z = this.position.z
                }

                // Check collision in Y direction
                const block_at_new_pos_y = this.world.getBlock(
                    this.position.x,
                    new_pos.y,
                    this.position.z
                )
                if(!block_at_new_pos_y?.passable) {
                    if(this.velocity.y < 0) {
                        this.isGrounded = true
                    }
                    this.velocity.y = 0
                    new_pos.y = this.position.y
                }

                this.position.copy(new_pos)

                if(this.isGrounded && move_up) {
                    // Клавиша пробела всё ещё зажата, вызываем jump()
                    this.jump()
                }
                return this.position
            }

            jump() {
                // Normal jump on land
                if (this.isGrounded && !this.inWater) {
                    this.velocity.y = this.jumpForce
                    this.isGrounded = false
                }
                // In water, jump key (move_up) is handled in update()
            }

            traceRay(origin, dir, any_block = false) {
                const pickat_distance = spectator_mode ? 100 : 20
                for(const result of this.raycast(origin, dir, pickat_distance, any_block)) {
                    return {...result, hit: true}
                }
                return { hit: false }
            }

            *raycast(origin, dir, pickat_distance, any_block) {
                const eps        = 1e-5
                const item       = {point: null, direction: null, side: null, block: null}
                const side       = new THREE.Vector3()
                const direction  = new THREE.Vector3().copy(dir).normalize()
                const step_x     = direction.x > 0 ? 1 : -1
                const step_y     = direction.y > 0 ? 1 : -1
                const step_z     = direction.z > 0 ? 1 : -1
                const t_delta_x  = Math.abs(direction.x) > eps ? Math.abs(1 / direction.x) : Number.MAX_VALUE
                const t_delta_y  = Math.abs(direction.y) > eps ? Math.abs(1 / direction.y) : Number.MAX_VALUE
                const t_delta_z  = Math.abs(direction.z) > eps ? Math.abs(1 / direction.z) : Number.MAX_VALUE
                let distance = 0
                let x = Math.floor(origin.x)
                let y = Math.floor(origin.y)
                let z = Math.floor(origin.z)
                let t_max_x = Math.abs(direction.x) > eps ? t_delta_x * (step_x > 0 ? 1 - (origin.x - x) : origin.x - x) : Number.MAX_VALUE
                let t_max_y = Math.abs(direction.y) > eps ? t_delta_y * (step_y > 0 ? 1 - (origin.y - y) : origin.y - y) : Number.MAX_VALUE
                let t_max_z = Math.abs(direction.z) > eps ? t_delta_z * (step_z > 0 ? 1 - (origin.z - z) : origin.z - z) : Number.MAX_VALUE
                const _block_vec = new THREE.Vector3()

                while(distance < pickat_distance) {
                    _block_vec.set(x, y, z).floor()
                    const block = this.world.getBlock(_block_vec.x, _block_vec.y, _block_vec.z)
                    if((block?.is_solid || block?.receive_ao || (any_block && block?.id != 0)) && (block?.id != blocks_palette.water.id)) {
                        item.point = direction.clone().multiplyScalar(distance).add(origin).round(4)
                        item.side = side.multiplyScalar(-1)
                        item.block_pos = _block_vec
                        item.block = block
                        item.direction = direction
                        yield item
                    }
                    if (t_max_x < t_max_y) {
                        if (t_max_x < t_max_z) {
                            side.set(step_x, 0, 0)
                            x += step_x
                            distance = t_max_x
                            t_max_x += t_delta_x
                        } else {
                            side.set(0, 0, step_z)
                            z += step_z
                            distance = t_max_z
                            t_max_z += t_delta_z
                        }
                    } else {
                        if (t_max_y < t_max_z) {
                            side.set(0, step_y, 0)
                            y += step_y
                            distance = t_max_y
                            t_max_y += t_delta_y
                        } else {
                            side.set(0, 0, step_z)
                            z += step_z
                            distance = t_max_z
                            t_max_z += t_delta_z
                        }
                    }
                }
                return null
            }

            breakBlock(event) {
                const direction = new THREE.Vector3()
                camera.getWorldDirection(direction)
                const origin = camera.position.clone()
                origin.y += player_height
                const result = this.traceRay(origin, direction, true)
                if(result.hit) {
                    const pos = result.block_pos
                    if(event.shiftKey) {
                        console.log(pos)
                        return
                    }
                    this.world.setBlock(pos.x, pos.y, pos.z, blocks_palette.air)
                    this.world.redrawNeibChunks(pos)
                }
            }

            placeBlock() {
                const direction = new THREE.Vector3()
                camera.getWorldDirection(direction)
                const origin = camera.position.clone()
                origin.y += player_height
                const result = this.traceRay(origin, direction)
                if(result.hit) {
                    const pos = result.block_pos.clone().add(result.side)
                    this.world.setBlock(pos.x, pos.y, pos.z, this.inventory.current_block)
                    this.world.redrawNeibChunks(pos)
                }
            }

            cloneBlock() {
                const direction = new THREE.Vector3()
                camera.getWorldDirection(direction)
                const origin = camera.position.clone()
                origin.y += player_height
                const result = this.traceRay(origin, direction, true)
                if(result.hit) {
                    this.inventory.current_block = result.block
                }
            }
        }

        class VectorCollector {

            constructor() {
                this.list = new Map()
                this.size = 0
            }

            has(xyz) {
                const { x, y, z } = xyz
                return this.list.get(x)?.get(y)?.has(z) || false
            }

            set(xyz, value) {
                const { x, y, z } = xyz
                let xv = this.list.get(x)
                if(!xv) {
                    xv = new Map()
                    this.list.set(x, xv)
                }
                let yv = xv.get(y)
                if(!yv) {
                    yv = new Map()
                    xv.set(y, yv)
                }
                this.size++
                yv.set(z, value)
            }

            get(xyz) {
                const { x, y, z } = xyz
                return this.list.get(x)?.get(y)?.get(z) || null
            }

            delete(xyz) {
                const { x, y, z } = xyz
                if(this.has(xyz)) {
                    this.size--
                    this.list.get(x).get(y).delete(z)
                    if(this.list.get(x).get(y).size == 0) {
                        this.list.get(x).delete(y)
                        if(this.list.get(x).size == 0) {
                            this.list.delete(x)
                        }
                    }
                }
            }

            values() {
                const that = this;
                return (function* () {
                    for (const x of that.list.values()) {
                        for (const y of x.values()) {
                            for (const value of y.values()) {
                                yield value
                            }
                        }
                    }
                })()
            }

        }

        class World {
            seed = null

            constructor(chunk_size, seed) {
                this.chunk_size = chunk_size
                this.seed = seed
            }

            getMemoryUsage() {
                return matrix.map(chunk => chunk?.getMemoryUsage() ?? 0).reduce((a, b) => a + b, 0)
            }

            getChunkAddr(x, y, z, out) {
                return (out || _ca).set(
                    Math.floor(x / this.chunk_size.x),
                    0,
                    Math.floor(z / this.chunk_size.z)
                )
            }

            getBlock(x, y, z) {
                const chunk_addr = this.getChunkAddr(x, y, z)
                const chunk = getChunk(chunk_addr)
                return chunk ? chunk.getBlock(x - chunk.coord.x, y - chunk.coord.y, z - chunk.coord.z) : blocks_palette.air
            }

            getBlockID(x, y, z) {
                const chunk_addr = this.getChunkAddr(x, y, z)
                const chunk = getChunk(chunk_addr)
                return chunk ? chunk.getBlockID(x - chunk.coord.x, y - chunk.coord.y, z - chunk.coord.z) : 0
            }

            setBlock(x, y, z, block) {
                const chunk_addr = this.getChunkAddr(x, y, z)
                let /** @type Chunk */ chunk = getChunk(chunk_addr)
                if(chunk) {
                    chunk.setBlock(x - chunk.coord.x, y - chunk.coord.y, z - chunk.coord.z, block)
                    for(const [key, mesh] of Object.entries(chunk.meshes)) {
                        mesh?.dispose()
                        chunk.meshes[key] = null
                    }
                    chunk.makeVertices()
                }
            }

            remakeVertices(chunk) {
                if(chunk.neighbours_mask !== 15) return
                for(const [key, mesh] of Object.entries(chunk.meshes)) {
                    mesh?.dispose()
                }
                chunk.init(chunk.addr)
                chunk.makeVertices()
            }

            redrawNeibChunks(block_pos) {
                const x = ((block_pos.x % chunk_size.x) + chunk_size.x) % chunk_size.x
                const z = ((block_pos.z % chunk_size.z) + chunk_size.z) % chunk_size.z
                const chunk_addr = this.getChunkAddr(block_pos.x, block_pos.y, block_pos.z)
                const chunk = getChunk(chunk_addr)
                if(chunk) {
                    if(x == 0) this.remakeVertices(getChunk(_un_vec.set(chunk_addr.x - 1, 0, chunk_addr.z)))
                    if(x == chunk_size.x - 1) this.remakeVertices(getChunk(_un_vec.set(chunk_addr.x + 1, 0, chunk_addr.z)))
                    if(z == 0) this.remakeVertices(getChunk(_un_vec.set(chunk_addr.x, 0, chunk_addr.z - 1)))
                    if(z == chunk_size.z - 1) this.remakeVertices(getChunk(_un_vec.set(chunk_addr.x, 0, chunk_addr.z + 1)))
                }
            }

        }

        class CubesMeshBuilder {

            constructor(chunk, world, shader_material) {
                this.chunk              = chunk
                this.world              = world
                this.quads              = 0
                this.reserved_polygons  = 0
                this.vertex_size        = 3 // Vertices coordinates
                this.uvs_size           = 2 // UV coordinates
                this.color_size         = 3 // Color values
                this.flag_size          = 1 // Flag values
                this.resize_factor      = 1.5 // Coefficient of buffer resizing
                this.used_polygons      = 0
                this.mesh               = new THREE.Mesh(new THREE.BufferGeometry(), shader_material)
                this.mesh.castShadow = true
                this.mesh.receiveShadow = true
                // this.buffer             = new ArrayBuffer(0)
                this.attributes = [
                    {name: 'position', size: this.vertex_size, array: null /* new Float32Array(this.buffer, 0, 0)*/},
                    {name: 'uv', size: this.uvs_size, array: null /* new Float32Array(this.buffer, 0, 0)*/},
                    {name: 'color', size: this.color_size, array: null /* new Float32Array(this.buffer, 0, 0)*/},
                    {name: 'flag', size: this.flag_size, array: null /* new Float32Array(this.buffer, 0, 0)*/},
                ]
                this.total_attrs_size = 0
                for(const { size } of this.attributes) {
                    this.total_attrs_size += size
                }
            }

            dispose() {
                this.used_polygons = 0
                this.quads = 0
                scene.remove(this.mesh)
                this.mesh.geometry.dispose()
                this.mesh.geometry = new THREE.BufferGeometry()
                this.reserved_polygons = 0
                this.buffer = new ArrayBuffer(0)
                for (const attr of this.attributes) {
                    attr.array = null
                }
            }

            // Resize buffers if needed
            _resizeBuffers(add_count) {
                if (this.used_polygons + add_count < this.reserved_polygons) {
                    return
                }
                stata.resize++;
                const polygons = this.reserved_polygons = Math.floor((this.reserved_polygons + 1000) * this.resize_factor)
                const total_count = polygons * this.total_attrs_size
                const new_buffer = this.buffer = new ArrayBuffer(total_count * Float32Array.BYTES_PER_ELEMENT * vpp)
                let offset = 0
                for(const attr of this.attributes) {
                    const new_array = new Float32Array(new_buffer, offset, polygons * attr.size * vpp)
                    attr.array && new_array.set(attr.array)
                    attr.array = new_array
                    offset += new_array.byteLength
                }
            }

            updateMesh() {
                const geometry = this.mesh.geometry
                const cnt = this.used_polygons * vpp
                const { attributes } = this
                for(const { array, name, size } of attributes) {
                    if(!array) {
                        geometry.deleteAttribute(name)
                        continue
                    }
                    const new_size = cnt * size
                    const attribute = geometry.getAttribute(name)
                    if(!attribute || attribute.array.length < new_size) {
                        stata.new_array++
                        geometry.setAttribute(name, new THREE.Float32BufferAttribute(array.slice(0, new_size), size))
                    } else {
                        // attribute.array.set(array.slice(0, new_size))
                        attribute.needsUpdate = true
                    }
                }
                geometry.computeVertexNormals()
                geometry.computeBoundingBox()
                geometry.computeBoundingSphere()
            }

            // 
            addPlant(x, y, z, block) {
                const face = block.faces[0]
                const random = pseudoRandom(x * 256 + z)
                x += random() * 0.2 - 0.1
                z += random() * 0.2 - 0.1
                for(let i = 0; i < planting_offsets.length; i++) {
                    this.addFace(x, y, z, 0, face, planting_offsets[i])
                }
            }

            // Add cube to mesh
            addCube(x, y, z, block, neighbours) {
                for (let i = 0; i < 6; i++) {
                    if (neighbours[i]) continue // If neighbour solid block exists, skip face
                    const face = block.faces[i]
                    if(face) this.addFace(x, y, z, i, face, face_offsets[i])
                }
            }

            addFace(x, y, z, face_direction, face, face_offsets) {

                this._resizeBuffers(2)

                const { vertices, uv } = face_offsets
                const hs               = 0.5
                const face_uv          = face.texture?.uv ?? empty_face
                const chunk            = this.chunk
                const coord            = chunk.coord
                const [ attr_position, attr_uv, attr_color, attr_flag ] = this.attributes
                let used_polygons = this.used_polygons
                let vi            = used_polygons * this.vertex_size * vpp
                let ui            = used_polygons * this.uvs_size * vpp
                let ci            = used_polygons * this.color_size * vpp
                let fi            = used_polygons * this.flag_size * vpp

                if(!attr_position) debugger

                for (let i = 0; i < vertices.length; i += 3) {
                    attr_position.array[vi++] = x + hs * vertices[i] + 0.5
                    attr_position.array[vi++] = y + hs * vertices[i + 1] + 0.5
                    attr_position.array[vi++] = z + hs * vertices[i + 2] + 0.5
                    // Add UV, scaling them by u, v, u2, v2 values
                    attr_uv.array[ui++] = uv[(i / 3) * 2] === 0 ? face_uv[0] : face_uv[2]
                    attr_uv.array[ui++] = uv[(i / 3) * 2 + 1] === 0 ? face_uv[1] : face_uv[3]
                }

                // Add color and flag values
                for(let p = 0; p < 6; p++) {
                    const ao_value = chunk.calculateAO(x, y, z, face_direction, p)
                    attr_color.array[ci++] = ao_value
                    attr_color.array[ci++] = ao_value
                    attr_color.array[ci++] = ao_value
                    attr_flag.array[fi++] = face.flag || 0
                }

                scene_info.quads++
                this.quads++
                chunk.quads++
                this.used_polygons += 2

            }

            getMemoryUsage() {
                return this.buffer.byteLength
            }

        }

        class Chunk {
            quads = 0
            dirty = false
            neighbours_mask = 0 // bit mask (1:x, 2:-x, 4:z, 8:-z)

            /**
             * @type {[key: string]: CubesMeshBuilder}
             */
            meshes = {
                regular: null,
                doubleside: null,
                transparent: null,
            }

            constructor(world) {
                this.world = world
                this.size = world.chunk_size
                this.seed = world.seed
                this.blocks = new Uint8Array(this.size.x * this.size.y * this.size.z)
                stata.chunks++
            }

            init(addr) {
                stata.chunk_inites++;
                this.reused = !!this.addr
                const { size } = this
                this.addr = addr.clone()
                this.coord = addr.clone().multiply(size)
                for(const mesh of Object.values(this.meshes)) {
                    if(mesh) {
                        scene.add(mesh.mesh)
                        mesh.updateMesh()
                    }
                }
                this.dirty = false
            }

            getMemoryUsage() {
                let memory_usage = this.blocks.byteLength
                for(const mesh of Object.values(this.meshes)) {
                    memory_usage += mesh?.getMemoryUsage() ?? 0
                }
                return memory_usage
            }

            getIndex(x, y, z) {
                return x + y * this.size.x + z * this.size.x * this.size.y
            }

            getBlock(x, y, z) {
                x = Math.floor(x)
                y = Math.floor(y)
                z = Math.floor(z)
                if (!this.isInBounds(x, y, z)) return blocks_palette.air // null
                const index = this.getIndex(x, y, z)
                const block_id = this.blocks[index]
                return block_id ? block_by_id[block_id] : blocks_palette.air
            }

            getBlockID(x, y, z) {
                x = Math.floor(x)
                y = Math.floor(y)
                z = Math.floor(z)
                if (!this.isInBounds(x, y, z)) return 0
                const index = this.getIndex(x, y, z)
                return this.blocks[index]
            }

            setBlock(x, y, z, block) {
                x = Math.floor(x)
                y = Math.floor(y)
                z = Math.floor(z)
                if(!this.isInBounds(x, y, z)) return
                const index = this.getIndex(x, y, z)
                this.blocks[index] = block.id
            }

            setNeighbour(mask, chunk) {
                if(this.dirty && chunk) return
                if(chunk) {
                    this.neighbours_mask |= mask
                } else {
                    this.neighbours_mask &= ~mask
                }
            }

            updateNeighbours() {
                const { addr, world } = this
                const chunk_px = getChunk(_un_vec.set(addr.x + 1, addr.y, addr.z))
                const chunk_nx = getChunk(_un_vec.set(addr.x - 1, addr.y, addr.z))
                const chunk_pz = getChunk(_un_vec.set(addr.x, addr.y, addr.z + 1))
                const chunk_nz = getChunk(_un_vec.set(addr.x, addr.y, addr.z - 1))
                if(chunk_px && !chunk_px.dirty) { this.setNeighbour(1, chunk_px); chunk_px.setNeighbour(2, this) }
                if(chunk_nx && !chunk_nx.dirty) { this.setNeighbour(2, chunk_nx); chunk_nx.setNeighbour(1, this) }
                if(chunk_pz && !chunk_pz.dirty) { this.setNeighbour(4, chunk_pz); chunk_pz.setNeighbour(8, this) }
                if(chunk_nz && !chunk_nz.dirty) { this.setNeighbour(8, chunk_nz); chunk_nz.setNeighbour(4, this) }
            }

            generate() {

                const pn = performance.now()
                const { size, addr, coord } = this

                let iter = 0
                let n0 = 0
                let n2 = 0
                let ocean = 0
                let planing = 0

                const setBlock = this.setBlock.bind(this)

                function getXZNoise(x, z) {
                    const x2 = x + 1024
                    const z2 = z + 1024
                    n0 = simplex.noise2D(x / 2, z / 2)
                    const n1 = simplex.noise2D(x / 64, z / 64)
                    n2 = simplex.noise2D(x2 / 16, z2 / 16)
                    const n3 = simplex.noise2D(x2 / 8, z2 / 8)
                    return (n1 * 0.7 + n2 * 0.25 + n3 * 0.05)
                }

                function calcH(x, z) {
                    ocean = simplex.noise2D((x - 8192) / 384, (z - 8192) / 384)
                    planing = (simplex.noise2D((x - 1024) / 256, (z - 1024) / 256))
                    const height = getXZNoise(x, z) * (32 * ((planing + 1) / 2))
                    return Math.ceil (
                        (64 + ocean * 16) + (height < 0 ? height : height * 2)
                    )
                }

                function drawTree(x, y, z, random) {
                    const height = Math.ceil(random() * 8 + 2)
                    for(let yy = 0; yy < height; yy++) {
                        setBlock(x, y + yy, z, blocks_palette.oak_log)
                    }
                    // draw leaves
                    const radius = {xz: 3, y: 7}
                    const ax = x
                    const ay = y + height - 2
                    const az = z
                    for(let xx = -radius.xz; xx <= radius.xz; xx++) {
                        for(let yy = 0; yy <= radius.y; yy++) {
                            for(let zz = -radius.xz; zz <= radius.xz; zz++) {
                                if(xx * xx + yy * yy + zz * zz <= radius.xz * radius.xz) {
                                    if(xx == 0 && yy < 2 && zz == 0) continue
                                    setBlock(ax + xx, ay + yy, az + zz, blocks_palette.oak_leaves)
                                }
                            }
                        }
                    }
                }

                const random = pseudoRandom(addr.x * 256 + addr.z)

                for(let x = 0; x < size.x; x++) {
                    for(let z = 0; z < size.z; z++) {
                        const h = calcH(x + coord.x, z + coord.z)
                        const max_y = Math.max(h, water_level)
                        for(let y = 0; y < max_y; y++) {
                            if(y < h) {
                                let block = blocks_palette.stone
                                const y_from_top = h - y
                                if(y < 80 + n2 * (8 * planing)) {
                                    if(y == water_level - 1 && y == h - 1) {
                                        block = blocks_palette.sand
                                    } else if(y < n0 * 2 + 3) {
                                        block = blocks_palette.bedrock
                                    } else {
                                        if(y_from_top == 1 && y > water_level - 1) {
                                            block = blocks_palette.grass_block
                                            let gr = random()
                                            if(gr < .1) {
                                                gr /= .1
                                                const block = gr < .9 ? grasses[Math.floor((gr/.9) * grasses.length)] : plants[Math.floor(((gr-.9)/.1) * plants.length)]
                                                setBlock(x, y + 1, z, block)
                                            }
                                        } else if(y_from_top < 3) {
                                            block = y < water_level ? blocks_palette.gravel : blocks_palette.dirt
                                        }
                                    }
                                }
                                setBlock(x, y, z, block)
                            } else { //if(y < water_level && y >= h) {
                                setBlock(x, y, z, blocks_palette.water)
                            }
                        }
                        if(h > water_level && h < 75 && Math.round(random() * tree_chance) == 0) {
                            drawTree(x, h, z, random)
                        }
                    }
                }

                this.updateNeighbours()

            }

            isInBounds(x, y, z) {
                return x >= 0 && x < this.size.x &&
                    y >= 0 && y < this.size.y &&
                    z >= 0 && z < this.size.z
            }

            checkSolidNeighbours(x, y, z, neighbours, transparent) {
                const { coord, size } = this
                let cnt = 0
                for (let i = 0; i < 6; i++) {
                    const nx = x + directions[i].x
                    const ny = y + directions[i].y
                    const nz = z + directions[i].z
                    let block_id = 0
                    if(ny < 0 || ny >= size.y) {
                        block_id = blocks_palette.air.id
                    } else if(this.isInBounds(nx, ny, nz)) {
                        block_id = this.blocks[this.getIndex(nx, ny, nz)]
                    } else {
                        const chunk_addr = world.getChunkAddr(nx + coord.x, ny + coord.y, nz + coord.z)
                        const chunk = getChunk(chunk_addr)
                        if(chunk) {
                            const bx = ((nx + chunk.coord.x) % size.x + size.x) % size.x
                            const by = ((ny + chunk.coord.y) % size.y + size.y) % size.y
                            const bz = ((nz + chunk.coord.z) % size.z + size.z) % size.z
                            block_id = chunk.blocks[chunk.getIndex(bx, by, bz)]
                        } else {
                            console.log(999)
                        }
                    }
                    if(!block_id) {
                        neighbours[i] = 0
                    } else {
                        const block = block_by_id[block_id]
                        neighbours[i] = (block.is_solid && (!block.transparent || transparent)) ? block.id : 0
                    }
                    cnt += neighbours[i] ? 1 : 0
                }
                return cnt !== 6
            }

            addMaterialMesh(material_name) {
                stata.meshes++;
                const mesh = this.meshes[material_name] = new CubesMeshBuilder(this, world, shader_materials[material_name])
                scene.add(mesh.mesh)
                return mesh
            }

            makeVertices() {

                const { blocks, size } = this

                let { doubleside, regular, transparent } = this.meshes
                for(let i = 0; i < blocks.length; i++) {
                    const block_id = blocks[i]
                    if(!block_id) continue
                    const block = block_by_id[block_id]
                    const x = i % size.x
                    const y = Math.floor(i / size.x) % size.y
                    const z = Math.floor(i / (size.x * size.y))
                    if(!block.is_solid || this.checkSolidNeighbours(x, y, z, neighbours_cache, block.transparent)) {
                        switch(block.style) {
                            case 'planting': {
                                doubleside ??= this.addMaterialMesh('doubleside')
                                doubleside.addPlant(x, y, z, block)
                                break
                            }
                            default: {
                                if(block.transparent) {
                                    transparent ??= this.addMaterialMesh('transparent')
                                    transparent.addCube(x, y, z, block, neighbours_cache)
                                } else {
                                    regular ??= this.addMaterialMesh('regular')
                                    regular.addCube(x, y, z, block, block.is_solid ? neighbours_cache : neighbours_empty)
                                }
                            }
                        }
                    }
                }

                this.update()

            }

            _getBlockID(x, y, z) {
                if(this.isInBounds(x, y, z)) {
                    return this.blocks[this.getIndex(x, y, z)]
                }
                const { coord, size } = this
                const chunk_addr = world.getChunkAddr(x + coord.x, y + coord.y, z + coord.z)
                const chunk = getChunk(chunk_addr)
                return chunk ? chunk.blocks[chunk.getIndex(
                    ((x + coord.x) % size.x + size.x) % size.x,
                    ((y + coord.y) % size.y + size.y) % size.y,
                    ((z + coord.z) % size.z + size.z) % size.z,
                )] : 0
            }

            _calcAO(x, y, z, ax, ay, az, fix) {
                let ao_value = 1
                let side1, side2
                let corner_block_id = this._getBlockID(x + ax, y + ay, z + az)
                switch(fix) {
                    case 0: {
                        side1 = this._getBlockID(x + ax, y + ay, z)
                        side2 = this._getBlockID(x + ax, y, z + az)
                        break
                    }
                    case 1: {
                        side1 = this._getBlockID(x + ax, y + ay, z)
                        side2 = this._getBlockID(x, y + ay, z + az)
                        break
                    }
                    case 2: {
                        side1 = this._getBlockID(x + ax, y, z + az)
                        side2 = this._getBlockID(x, y + ay, z + az)
                        break
                    }
                }
                const side1_block = side1 ? block_by_id[side1] : null
                const side2_block = side2 ? block_by_id[side2] : null
                const corner_block = corner_block_id ? block_by_id[corner_block_id] : null
                if((side1_block?.is_solid || side1_block?.receive_ao) && !side1_block.transparent) ao_value -= 0.25
                if((side2_block?.is_solid || side2_block?.receive_ao) && !side2_block.transparent) ao_value -= 0.25
                if((corner_block?.is_solid || corner_block?.receive_ao) && !corner_block.transparent) ao_value -= 0.25
                return ao_value
            }

            calculateAO(x, y, z, i, p) {
                let ao_value = 1
                if(i != 1) {
                    const index = ao_indexes[p]
                    const a = ao_table[i]
                    const b = a.moves[index]
                    ao_value = this._calcAO(x, y, z, b[0], b[1], b[2], a.fix)
                }
                const ao_strenght = 0.8
                if(ao_value < 1 && ao_strenght != 1) {
                    ao_value *= ao_strenght
                }
                return ao_value
            }

            update() {
                for(const mesh of Object.values(this.meshes)) {
                    if(mesh) {
                        mesh.updateMesh()
                        const shift = getPlayerPosition().clone().add(acc_shift)
                        mesh.mesh.position.set(
                            this.coord.x - shift.x,
                            0,
                            this.coord.z - shift.z,
                        )

                    }
                }
            }

            dispose() {
                const { addr } = this
                this.dirty = true
                scene_info.quads -= this.quads
                this.quads = 0
                for(const [key, mesh] of Object.entries(this.meshes)) {
                    mesh?.dispose()
                }
                this.neighbours_mask = 0
                this.blocks.fill(0)
            }

        }

        const directions = [
            { x: 0, y: 1, z: 0 },  // Up
            { x: 0, y: -1, z: 0 }, // Bottom
            { x: 0, y: 0, z: 1 },  // Front
            { x: 0, y: 0, z: -1 }, // Back
            { x: -1, y: 0, z: 0 }, // Left
            { x: 1, y: 0, z: 0 }   // Right
        ]

        const textures = {
            dirt: {bin: 'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQBAMAAADt3eJSAAAAFVBMVEW5hVyHh4eWbEpsbGx0WER5VTpZPSnqDkA3AAAAbklEQVR42hXLwQnDQAwEwOVA7uDyNgq6AtJD/mLD6m0Muv5LCJ7/YES6OhNsvjLGhpXJtA1vW+nMQJy31o+Ncu4uJUwzDSQE13I5giyGGuxqCQTTxnX4RPDkJ+5ChZskgPp6HemIqwp8+ojp8voDZ2EdYwBe7AYAAAAASUVORK5CYII='},
            bedrock: {bin: 'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAAAAAA6mKC9AAAAcElEQVR42jWPMQ0DQBSFvpazgBgEPFHYbdKmCwth4AZgM0E8ttai9pDjwQNCzZ1tPlMAvEcAwmrjUFF4X3A190e8U/EnkXkrQVeruq8TmUC7LVY8qsE9FVy51TuBCQsAby2fwMPVbcI/An9zNdwD9wFD0lUf95ycGwAAAABJRU5ErkJggg=='},
            gravel: {bin: 'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQBAMAAADt3eJSAAAAGFBMVEWwrq6xoqKXl5eWjo6JgX6Bf39ya2lkW1tYVrIwAAAAe0lEQVR42g3GwRECIQwF0D/MWIENODtk7YC7DOFulqQANFCAsvXrOz18Uxd3MZBptVUydNZCbf+HueveFO9ncp3CWK+zUCBD/Wjo8VRsHKkNjYjkra6bo41gxMbwHKcY36ExXwaLwVjlkTZBmdIONULmMo4yM/zqyuz+A5MJJSnE6Mt8AAAAAElFTkSuQmCC'},
            oak_leaves: {bin: 'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQBAMAAADt3eJSAAAAD1BMVEUAAAC5vLmYmZh3dXdoZGjJX6haAAAAAXRSTlMAQObYZgAAAGlJREFUeNoFgAERwyAMAD8pAtJ0AgIYaAEBbI1/TTtSNOaPiyCHDqkwtVvIia7tHzB6p1IatFtW8gazuB93e1j7tBwy8PJtR4+OkW+0cDR2exThSqQeASMalo9QZe2iV8XcmbgRp5W8Rf/WMg1MmmHulQAAAABJRU5ErkJggg=='},
            oak_log: {bin: 'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQBAMAAADt3eJSAAAAElBMVEWYeEmRcUJ0WjZfSitMPSY4Kxj0FtFUAAAAaklEQVR42hXGQRHDMAwEQI1VBJINwLoTgLgEaiHohD+YOPtaoaXl3BBqas6C5DeVPBkgkOXSkVDQxKpT+8kqX2ZvbrvCYcJ/XHA3iV8sdLslJhI84UnLVvIJH5qxpJXRGSG2Y5D7TXXGxgPEiBE7ybf/RAAAAABJRU5ErkJggg=='},
            oak_log_top: {bin: 'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQBAMAAADt3eJSAAAAG1BMVEXCnWK4lF+vj1WfhE2WdEF+Yjd0WjZfSitMPSYsJcj4AAAAf0lEQVR42hXJsQ3CMBAF0H/OFxGNfZHoI8gqzMIMjMFCVGwAdQCxgO8EHZKP8NrHY0vhRY3rk8BG62n7aoHpQnzPKtEpxbcAXFksjZ6vQh8+D2StRA0pVjfEQvECFYinqtD0PbX6L2szIGCBBYJLdTsFcCPm4Z5TXbE/SHgp/gPG/zIQFSN2ggAAAABJRU5ErkJggg=='},
            stone: {bin: 'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAAAAAA6mKC9AAAAZElEQVR42jWNsQ0AMQjEGJcB3HsEr/xSkncBOgkfUyXIguoo4mEXGdkFFvBdlGmpwKCAWIWOeYFladCK4n2BXZZn6vR3dsXRfLnKWfFoXmtUrX81AiboaZ9u4I1G8KdqPICl6AdyLn2NfcJFIAAAAABJRU5ErkJggg=='},
            stone_bricks: {bin: 'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQBAMAAADt3eJSAAAAFVBMVEWcmZyLiYt/f394dnhqbWpjY2NaWVo/4AZ+AAAAbUlEQVR42hWJsREDIRDEuC3A7F7gmKMDXK5bIHFLXwHwDWBeo0AzAtOD3rhd8qqEnSUOEqZh29cTMZA1wb0iXy+iIeQNhKpqSBn923/9gCbnOhcXSWMh8jLavTaMeR4dCk97lQlZ4ic8IKlUSX8TNSDr6TM/jQAAAABJRU5ErkJggg=='},
            sand: {bin: 'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQBAMAAADt3eJSAAAAElBMVEXt68vn5Lvj27Daz6PVxJbRuopf1Q47AAAAZklEQVR42gVAwQ3CMBCzQPyRukEcBqjP/dNzWAC6/ywIm0y2GrH72h47eJ1VdqDpOdqF3FuqCK7BzApOv7N+Nlyx126E+nQYbKl1uCYOWcVLWMWMlSDdfnIJ5EtSBdKN5LdADrnIP0wTGY7btIheAAAAAElFTkSuQmCC'},
            grass_block_top: {bin: 'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAADAFBMVEU3Wx5IeCg2Wh4xUhs1WB0vTho0Vh06YSA3XB8zVRwyUxwyVBw+ZyIpRRc0Vx03XB47YiE4XR84Xh8vTxowUBo+aCI9ZiIzVhw8ZCEuTRkxURs1WR07YiBAaiMsSRhDcCUrSRg1WR4wURs/aiNAayNFciYrSBg/aSMuThosShgwTxo5XyA5YCBDbyUuTBk8ZSFCbiRDcSVHdictShktTBktSxk7YyFGdicAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEdUADQdjt2OxUAAAAAAAABAAAAAABzhKHtiHcAAE8AAAAAADAAAAAAAAAAAABzhPgAAHcAAAAAAAAAAAAAAAB0AAB2OxYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB4gBTQOHcAAIMAfQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGQAAADIAAAAh/UAADYAAAAQAAAANgCDs1jQOAC4AIMAh/V9AAAAAADEAAAAT+10PTau2XcAd3UAAAAAAAAAAAAAAAAAAAAAAADvRADOvYB2LAhP7mgJKQC3diwAAAAAAAAAAACewAB2LAkAAGAABQCAAAAAAAAQAIAAAMBwAAAAAAYAAAAAAwAAAAAAAAB6AHjQOACAAIMAT+4AAAAAAAA4AAAAg9AAAACzYAAAd3cAAAAAAAAAAAAAAAAAAAAAABgAAAAIAAAAT+4AAEAAAABYAAAAT+6o1rAAAAkMAH3zqL15AAAAAWJLR0SL8m9H4AAAAAlwSFlzAAALEwAACxMBAJqcGAAAAOFJREFUGNMNzMligjAUAMDHSwJkaSBhDUgR0ILBKhVr///P6nEuAxAgIZSFUcyFVB8akjA1NrM5K0oMQlFBrV0jZdvCQXXiM+vhSLgZrEM2akMr5aAeu3E6yen8lal5kRqsvZQ+TlaRyPHyNizXssWRs0Z8T4MyFKiIqvZ2b0wnPE1ZAWrt58l3123OkWC0gMl/dGjnTAxY6I16WCNT5r3Gx65GKt9H05HaNCgNhs+NOQ5n47kdyC8fuDuUuwGvjuisD16o1lSqE9Svx3ObAZckEUVU7UBiKe8WUP/diqaV0T9QvxT8vFJhIAAAAABJRU5ErkJggg=='},
            water_still: {bin: 'iVBORw0KGgoAAAANSUhEUgAAABAAAAIABAMAAAB5lPHgAAAAJ1BMVEX////5+fnY2NjW1tbV1dXT09PS0tLPz8/Ozs7CwsK4uLiurq6lpaUTLc7BAAAADXRSTlO0tLS0tLS0tLS0tLS0frXQ3wAABWRJREFUeNqN2D2OHLcSB/AC3pO8/XyCd4B3hHcE5+Ng1qY62UQCBpsosAwoE+AvbDZJD1BbSmXA2MTJGqD/dYOqQ3lYZH/M9IxsBgOCPWz+UF1kk00CN+DwHbkDcHcqP2BxUs8CBsihbm4gVwhEnQSl3Hb0TY9SZ6J0l3KWZ/Io5hR9MkDemqhdiUsAq5YWy/ReKePr/0IAegrP8OPKg5VHyN0E4k4YPd8Wj4bnZoe1ByuPn3k800PxbDoIhPrwPP8rPLb25PBg5VEAh442T3gKz4t0k5D7yWMUoVh4fOVB9dw1Ty6eBDdB/jeZQ+PPBnNIeHDJg/A4BL92tBf04dm9Onq4eczC49c9DjCa53D04MzzI5nntQeTx1cexmHhSdubHsNu8sRYduoxd1t7MITndjd5GPmH2QOYG48ehEeXHl14DsXjloiH4ukemwfNY9DZAzPTUpHqsaVnSNxnoaSeOeJjvPT0xWNLT36qHh095XkNk4dJjsBMQUduHr/msdnzGB7mYeH5YeFRjB6HhcfC05O5ifrSw8i9Ljw8enJj2KkHk2fOnz+b53A/e36ZPRnFcw+SMSH1gkfBZb4LcgqP8EvB/ujBZzxYemT05PBkPvbG0aP5lRQPhuphKZ4vc/XY6DFw8/jCg8mT00UPrniQV55N8zxvhb8gw3bp6U48Xj2+9GRswsPNw8Bh9gyN0Qa1uPPSA1z09EfPo/AN+egZiietPIAUz1P1ZMwehAcCDN1AcuaRhUcNWHu4q567h4gPnlmYyPH6Y3j2PdxeFY/OHm0eyMJze+7Ju+3oOZBe8xjhkifT++LB5Hkhpu602cFt+2KgvnoyqYcHlzwGwO235knV41c9DD3xqDuPnpt3zTMIb2fPvtOj5+eB7hcehEcnD4rnsCN4eLh5+M3Kg7/xWPNg8vxx9DyS5zE+xfP6w0BdeDKTX/EMqXp09ODo4aoYrnmw9txXD33FIC6exEyWO/HJ8+bt2qMrDxPcqqdHtL0k1s95PoVHTz198/xPQCz4/ZCkeXz0vHz7if5zydMSEgCDZfTk0fOmeSQvPK1QVtsK6kbIZk+WM89mJ5mMd6MHxbOlnz5G9g+zB3/reT15GsNOPRuGY/Ro9eCKJ4Wnzi96m5Yeg517ZPJY87gjb2fPetuD4pEzDwQYPQjPvnm4evZp9Ejx/DZ6ZOUZmMQNrj56kJoHuOjBXRo9duLx6lHKOPfE+vzhLdNPOnl89DjQ8plTnV8W45NUD1P+nMc2SVyj5YLn/1ASYH8b+SzNw6OnCw8zuauGx7wtsLNHDf/c47YRXPd81TxblmHhARwfvl96TKMfmfvoEU44JMrhMZAwoJB81RMM24dHTz3SPO+q55Bk6cnFQ++EduGRXPeHQHiiWjxpV9Znnj0MZEH12AUPSE88uc332fO+eNQGBn4tno/NY270AHqqM6XuD9tOODxGCqSE4X72gBlaPKgeu+Bxt9+XHg0PIE5uyHcPNT6PjLwpHjQPLL/sQBIKAVUEEB7U+HDaYehoACQ8zFtBCSbO4qMnnj9mDwuap1cyZL7rABJY5qNt9gBmeBEeg+XwYI4PEJ6cUvEcAIGbEPPt0mPNY2eeZ8C9eMwYzZPj/cV82zyQ8ACwEw8UwJnHJg+HZy+T5656tHqseVTJbfbkyYPJw1/W8852Fx4vnpuFR82x68885sWjkwfMxbOpHqZUPPOyPHqAk/j45MHs+dQVz2HHqXoMyF+QKYDqcUeq5/fxfKqTRyDT+rxdeF7zXb/0+Oq8HELo7GnU/Oboydh3LJNn+OXq95a1R714wNP3DQcT8SYtPHXQtce8emzyWKaH6oEAfwHoySkS2Hjk2AAAAABJRU5ErkJggg=='},
            short_grass: {bin: 'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQBAMAAADt3eJSAAAAFVBMVEUAAAC4t7igoKCRkZGDgYN2d3ZsbGyS5OzOAAAAAXRSTlMAQObYZgAAAG5JREFUeNptyDESgyAQheHHSvpt7DcDpCaGHMABqRnwBI73P4Ng7Wv+bx6eJgSmAVJguau0cC/eND6AK61dHeS/emCeXJwJEKNe4rhAFirWS4UlU4IsE3xsbTcx4Jda3Fzy0PWs+W8TwnEeOX+2CxhUDj0662krAAAAAElFTkSuQmCC'},
            dandelion: {bin: 'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAUklEQVQ4y2NgGAXDHfx/4/8fhMnW/O+a5f+Pc1VJNwSkAaZxb5YS2CCyDCFbMwyI17D8B2GyNHr1a/wPXa0Lpsm2HWYACJPlEpABZHsDBIixGQCyM01OrS9sngAAAABJRU5ErkJggg=='},
            oxeye_daisy: {bin: 'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAATlBMVEXr6+tR2/1vtE0nrPtXpDJVnzFRoStQmShVkzJRkTFBixxDhiPBQCM5fhYyeg4AAAD39/fW6Oj/7E/+1jn1uiebvb3xnSVVqy1Smi4XfASspZShAAAAEHRSTlMAAAAAAAAAAAAAAAAAAAAAHik/2wAAAGZJREFUeNptyFEOAiAMBNGqiCJWdgWE3v+ixsSkjXG+Jk/aT/IX5D7BkzgcSIDNgRi9czoA/TkAh8nRX6BDIkBmB6nETOJQz7dtSR308lhaItheSQO0YqvYNYDWZbkFyLojfLLjd97lCA7ioBDbWwAAAABJRU5ErkJggg=='},
        }

        const blocks_palette = {
            air: {id: 0, faces: [], passable: 1},
            dirt: {id: 1, faces: [
                {color: [0.4039, 0.2667, 0.1294], flag: 32, texture: textures.dirt},
                {color: [0.4039, 0.2667, 0.1294], flag: 32, texture: textures.dirt},
                {color: [0.4039, 0.2667, 0.1294], flag: 32, texture: textures.dirt},
                {color: [0.4039, 0.2667, 0.1294], flag: 32, texture: textures.dirt},
                {color: [0.4039, 0.2667, 0.1294], flag: 32, texture: textures.dirt},
                {color: [0.4039, 0.2667, 0.1294], flag: 32, texture: textures.dirt},
            ], is_solid: true},
            grass_block: {id: 2, faces: [
                {color: [99/256, 127/256, 64/256], texture: textures.grass_block_top},
                {color: [0.4039, 0.2667, 0.1294], texture: textures.dirt},
                {color: [0.4039, 0.2667, 0.1294], flag: 2 | 32, texture: textures.dirt},
                {color: [0.4039, 0.2667, 0.1294], flag: 2 | 32, texture: textures.dirt},
                {color: [0.4039, 0.2667, 0.1294], flag: 2 | 32, texture: textures.dirt},
                {color: [0.4039, 0.2667, 0.1294], flag: 2 | 32, texture: textures.dirt},
            ], is_solid: true},
            stone: {id: 3, faces: [
                {color: [0.5451, 0.5333, 0.5294], texture: textures.stone},
                {color: [0.5451, 0.5333, 0.5294], texture: textures.stone},
                {color: [0.5451, 0.5333, 0.5294], texture: textures.stone},
                {color: [0.5451, 0.5333, 0.5294], texture: textures.stone},
                {color: [0.5451, 0.5333, 0.5294], texture: textures.stone},
                {color: [0.5451, 0.5333, 0.5294], texture: textures.stone},
            ], is_solid: true},
            water: {id: 4, faces: [
                {color: [63/256, 118/256, 228/256], flag: 1, texture: textures.water_still},
                null, // {color: [63/256, 118/256, 228/256], texture: textures.water_still},
                null, // {color: [63/256, 118/256, 228/256], texture: textures.water_still},
                null, // {color: [63/256, 118/256, 228/256], texture: textures.water_still},
                null, // {color: [63/256, 118/256, 228/256], texture: textures.water_still},
                null, // {color: [63/256, 118/256, 228/256], texture: textures.water_still},
            ], is_solid: true, transparent: true, passable: 1},
            sand: {id: 5, faces: [
                {color: [0.8, 0.8, 0.6], texture: textures.sand},
                {color: [0.8, 0.8, 0.6], texture: textures.sand},
                {color: [0.8, 0.8, 0.6], texture: textures.sand},
                {color: [0.8, 0.8, 0.6], texture: textures.sand},
                {color: [0.8, 0.8, 0.6], texture: textures.sand},
                {color: [0.8, 0.8, 0.6], texture: textures.sand},
            ], is_solid: true},
            oak_log: {id: 6, faces: [
                {color: [0.7, 0.7, 0.5], texture: textures.oak_log_top},
                {color: [0.7, 0.7, 0.5], texture: textures.oak_log_top},
                {color: [146/256, 108/256, 77/256], flag: 8, texture: textures.oak_log},
                {color: [146/256, 108/256, 77/256], flag: 8, texture: textures.oak_log},
                {color: [146/256, 108/256, 77/256], flag: 8, texture: textures.oak_log},
                {color: [146/256, 108/256, 77/256], flag: 8, texture: textures.oak_log},
            ], is_solid: true},
            oak_leaves: {id: 7, faces: [
                {color: [0.0, 0.6, 0.0], flag: 16, texture: textures.oak_leaves},
                {color: [0.0, 0.6, 0.0], flag: 16, texture: textures.oak_leaves},
                {color: [0.0, 0.6, 0.0], flag: 16, texture: textures.oak_leaves},
                {color: [0.0, 0.6, 0.0], flag: 16, texture: textures.oak_leaves},
                {color: [0.0, 0.6, 0.0], flag: 16, texture: textures.oak_leaves},
                {color: [0.0, 0.6, 0.0], flag: 16, texture: textures.oak_leaves},
            ], receive_ao: true},
            bedrock: {id: 8, faces: [
                {color: [0.1, 0.1, 0.1], texture: textures.bedrock},
                {color: [0.1, 0.1, 0.1], texture: textures.bedrock},
                {color: [0.1, 0.1, 0.1], texture: textures.bedrock},
                {color: [0.1, 0.1, 0.1], texture: textures.bedrock},
                {color: [0.1, 0.1, 0.1], texture: textures.bedrock},
                {color: [0.1, 0.1, 0.1], texture: textures.bedrock},
            ], is_solid: true},
            gravel: {id: 9, faces: [
                {color: [0.5, 0.5, 0.5], flag: 4, texture: textures.gravel},
                {color: [0.5, 0.5, 0.5], flag: 4, texture: textures.gravel},
                {color: [0.5, 0.5, 0.5], flag: 4, texture: textures.gravel},
                {color: [0.5, 0.5, 0.5], flag: 4, texture: textures.gravel},
                {color: [0.5, 0.5, 0.5], flag: 4, texture: textures.gravel},
                {color: [0.5, 0.5, 0.5], flag: 4, texture: textures.gravel},
            ], is_solid: true},
            short_grass: {id: 10, faces: [
                {color: [1, 1, 1], flag: 128 | 64, texture: textures.short_grass},
            ], style: 'planting', passable: 1},
            dandelion: {id: 11, faces: [
                {color: [1, 1, 1], flag: 128, texture: textures.dandelion},
            ], style: 'planting', passable: 1},
            oxeye_daisy: {id: 12, faces: [
                {color: [1, 1, 1], flag: 128, texture: textures.oxeye_daisy},
            ], style: 'planting', passable: 1},
        }

        const grasses = [blocks_palette.short_grass]
        const plants = [
            blocks_palette.dandelion, blocks_palette.oxeye_daisy,
            // poppy, blue_orchid, allium, azure_bluet, red_tulip, orange_tulip, white_tulip, pink_tulip, cornflower, lily_of_the_valley, sweet_berry_bush
        ]

        const block_by_id = new Array(256)
        for(const block of Object.values(blocks_palette)) {
            block_by_id[block.id] = block
        }

        const face_offsets = [
            { vertices: [-1, 1, -1, -1, 1, 1, 1, 1, 1, -1, 1, -1, 1, 1, 1, 1, 1, -1], uv: [0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0] }, // Up
            { vertices: [-1, -1, 1, -1, -1, -1, 1, -1, -1, -1, -1, 1, 1, -1, -1, 1, -1, 1], uv: [0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1] }, // Bottom
            { vertices: [-1, -1, 1, 1, -1, 1, 1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1], uv: [0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1] }, // Front
            { vertices: [-1, -1, -1, -1, 1, -1, 1, 1, -1, -1, -1, -1, 1, 1, -1, 1, -1, -1], uv: [0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0] }, // Back
            { vertices: [-1, -1, -1, -1, -1, 1, -1, 1, 1, -1, -1, -1, -1, 1, 1, -1, 1, -1], uv: [1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1] }, // Left
            { vertices: [1, -1, -1, 1, 1, -1, 1, 1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1], uv: [0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0] }, // Right
        ]

        const planting_scale = 0.8
        const planting_offsets = [
            // First plane (diagonal, XZ)
            {vertices: [
                -1 * planting_scale, -1, -1 * planting_scale,
                1 * planting_scale, -1, 1 * planting_scale,
                1 * planting_scale, -1 + planting_scale * 2, 1 * planting_scale,
                -1 * planting_scale, -1, -1 * planting_scale,
                1 * planting_scale, -1 + planting_scale * 2, 1 * planting_scale,
                -1 * planting_scale, -1 + planting_scale * 2, -1 * planting_scale,
            ], uv: [0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0]},
            // Second plane (diagonal, XZ)
            {vertices: [
                -1 * planting_scale, -1,  1 * planting_scale,
                1 * planting_scale, -1, -1 * planting_scale,
                1 * planting_scale, -1 + planting_scale * 2, -1 * planting_scale,
                -1 * planting_scale, -1,  1 * planting_scale,
                1 * planting_scale, -1 + planting_scale * 2, -1 * planting_scale,
                -1 * planting_scale, -1 + planting_scale * 2,  1 * planting_scale,
            ], uv: [0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0]},
        ]

        const ao_table = [
            {fix: 1, moves: [ [-1, 1, -1], [-1, 1, 1], [1, 1, 1], [1, 1, -1]] },
            null,
            {fix: 2, moves: [ [-1, -1, 1], [1, -1, 1], [1, 1, 1], [-1, 1, 1]] },
            {fix: 2, moves: [ [-1, -1, -1], [-1, 1, -1], [1, 1, -1], [1, -1, -1]] },
            {fix: 0, moves: [ [-1, -1, -1], [-1, -1, 1], [-1, 1, 1], [-1, 1, -1]] },
            {fix: 0, moves: [ [1, -1, -1], [1, 1, -1], [1, 1, 1], [1, -1, 1]] },
        ]

        const ao_indexes        = [0, 1, 2, 0, 2, 3]
        const vpp               = 3 // vertices per polygon
        const bob_зarams        = { time: 0, frequency: 8, amplitudeX: 0.05, amplitudeY: 0.1, amplitude: 0.1 }
        const seed              = 'seed' 
        const player_height     = 1.8
        const fog_color         = new THREE.Color(0.470588, 0.780392, 0.921569).convertSRGBToLinear() // Sky color (light blue) like in Minecraft
        const pnw               = performance.now()
        let render_distance     = 8
        const chunk_size        = {x: 16, y: 128, z: 16}
        let matrix_side         = render_distance * 2 + 1
        /**
         * @type {Array<Chunk>}
         */
        const matrix            = new Array(matrix_side ** 2) // chunks that have already been generated and are ready to be rendered
        const DEFAULT_SPAWN_POS = {x: (render_distance * chunk_size.x) / 2, y: 120, z: (render_distance * chunk_size.z) / 2}
        const scene_info        = { quads: 0 }
        const saved_pos         = localStorage.getItem('saved_pos')
        const player_position   = localStorage.getItem('player_position')
        const simplex           = new SimplexNoise('1')
        const world             = new World(chunk_size, seed)
        const start_position    = new THREE.Vector3().copy(player_position ? JSON.parse(player_position) : DEFAULT_SPAWN_POS)
        const player_controller = new PlayerController(world, 9.8, 0.9, start_position)
        const velocity          = new THREE.Vector3()
        const direction         = new THREE.Vector3()
        const _ca               = new THREE.Vector3()
        const _ca_gcaddr        = new THREE.Vector3()
        const up                = new THREE.Vector3(0, 1, 0)
        const _un_vec           = new THREE.Vector3()
        const neighbours_cache  = [0, 0, 0, 0, 0, 0]
        const neighbours_empty  = [0, 0, 0, 0, 0, 0]
        const empty_face        = [0, 0, 0, 0]
        const water_level       = 64
        const tree_chance       = 64
        const player_chunk_o    = new THREE.Vector3()
        const acc_shift         = new THREE.Vector3()

        globalThis.world = world
        globalThis.direction = direction

        let frame = 0
        let prev_rad = 0
        let stats
        let beft = 1
        let spectator_mode = localStorage.getItem('spectator_mode') === 'true'
        let move_forward = false, move_backward = false, move_left = false, move_right = false
        let move_up = false, move_down = false
        let speed_mul = 1
        let pnw1
        let shader_materials

        // 
        const scene = new THREE.Scene()
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000)
        const renderer = new THREE.WebGLRenderer({ antialias: false, precision: 'highp' })
        renderer.shadowMap.enabled = true
        renderer.shadowMap.type = THREE.PCFSoftShadowMap
        renderer.setPixelRatio(window.devicePixelRatio)
        renderer.setSize(window.innerWidth, window.innerHeight)
        const light = new THREE.DirectionalLight(0xffffff, 1)
        light.castShadow = true
        light.shadow.mapSize.width = 1024
        light.shadow.mapSize.height = 1024
        light.shadow.camera.near = 0.5
        light.shadow.camera.far = 500
        // light.position.set(0, 100, 0)
        scene.add(light)
        scene.background = fog_color
        camera.position.set(0, start_position.y, 0)

        // Создание геометрии сферы
        // const radius = 48
        // const width_segments = 64 // 40 x 40 = 1600 полигонов
        // const height_segments = 64
        // const geometry = new THREE.SphereGeometry(radius, width_segments, height_segments)
        // // Материал с полупрозрачностью
        // const material = new THREE.MeshBasicMaterial({
        //     color: 0x0077ff,
        //     transparent: true,
        //     side: THREE.DoubleSide,
        //     opacity: 0.5,
        //     depthWrite: false, depthTest: true, blending: THREE.NormalBlending
        // })
        // // Создание сферы
        // const sphere = new THREE.Mesh(geometry, material)
        // sphere.position.set(64, 70, 64) // Координаты для размещения
        // scene.add(sphere)

        const controls = new THREE.PointerLockControls(camera, document.body)

        // Create an element to display coordinates
        const coords_el = document.getElementById('coords')
        updateGamemodeString()

        function toggleGamemode() {
            spectator_mode = !spectator_mode
            updateGamemodeString()
        }

        function updateGamemodeString() {
            document.getElementById('gamemode').innerText = spectator_mode ? 'Spectator' : 'Survival'
        }

        function addListeners() {

            document.body.addEventListener('click', () => controls.lock())

            // on mouse wheel
            document.addEventListener('wheel', (event) => {
                speed_mul *= event.deltaY < 0 ? 1.1 : 0.9
            })

            document.addEventListener('mousedown', (event) => {
                if (event.button === 0 && controls.isLocked) player_controller.breakBlock(event)
                if (event.button === 1 && controls.isLocked) player_controller.cloneBlock()
                if (event.button === 2 && controls.isLocked) player_controller.placeBlock()
            })

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight
                camera.updateProjectionMatrix()
                renderer.setSize(window.innerWidth, window.innerHeight)
            })

            const handleKeyEvent = (event, is_key_down) => {
                const key_state = is_key_down;
                switch (event.code) {
                    case 'KeyW': move_forward = key_state; break
                    case 'KeyS': move_backward = key_state; break
                    case 'KeyA': move_left = key_state; break
                    case 'KeyD': move_right = key_state; break
                    case 'ShiftLeft': move_down = key_state; break
                    case 'Space': 
                        if (key_state) player_controller.jump()
                        move_up = key_state
                        break
                    case 'PageUp': {
                        if(key_state) {
                            render_distance = Math.min(64, render_distance + 1)
                        }
                        break
                    }
                    case 'PageDown': {
                        if(key_state) {
                            render_distance = Math.max(1, render_distance - 1)
                        }
                        break
                    }
                    case 'F4':
                        if (!key_state) {
                            const pos = {...getPlayerPosition()}
                            localStorage.setItem('player_position', JSON.stringify(pos))
                            localStorage.setItem('saved_pos', JSON.stringify(pos))
                            localStorage.setItem('spectator_mode', spectator_mode)
                            localStorage.setItem('rotation', JSON.stringify(camera.rotation.toVector3()))
                        }
                        break
                    case 'KeyR':
                        if (!key_state) {
                            let pos = localStorage.getItem('saved_pos')
                            teleportTo(pos ? JSON.parse(pos) : DEFAULT_SPAWN_POS)
                        }
                        break
                    case 'F8':
                        if (key_state) teleportRandomly()
                        event.preventDefault()
                        event.stopPropagation()
                        break;
                    case 'KeyP':
                        if (!key_state) printStat()
                        break;
                    case 'KeyG':
                        if (!key_state) {
                            toggleGamemode()
                            event.preventDefault()
                            event.stopPropagation()
                        }
                        break
                }
            };

            document.addEventListener('keydown', (event) => handleKeyEvent(event, true))
            document.addEventListener('keyup', (event) => handleKeyEvent(event, false))

        }

        function createShaderMaterial(texture, options = {}) {
            texture.minFilter = THREE.NearestFilter
            texture.magFilter = THREE.NearestFilter
            texture.needsUpdate = true
            return new THREE.ShaderMaterial({
                vertexColors: true,
                side: THREE.FrontSide,
                ...options,
                uniforms: {
                    data: { 
                        value: {
                            cameraPosition: new THREE.Vector3(),
                            cameraOffset: new THREE.Vector3(),
                            fogColor: new THREE.Color(0.470588, 0.780392, 0.921569),
                            fogNear: 100.0,
                            time: 1.0,
                            in_water: 0.0,
                            fogFar: render_distance * chunk_size.x,
                            texture: texture,
                            // shadowMatrix: { value: light.shadow.matrix },
                        }
                    }
                },
                vertexShader: `
                    struct Data {
                        vec3 cameraPosition;
                        vec3 cameraOffset;
                        vec3 fogColor;
                        float fogNear;
                        float fogFar;
                        float time;
                        float in_water;
                        sampler2D texture;
                        // mat4 shadowMatrix[NUM_DIR_LIGHTS];
                    };
                    uniform Data data;

                    // #include <common>
                    // #include <shadowmap_pars_vertex>
                    // #include <packing>

                    varying vec3 vColor;
                    varying vec3 vWorldPosition;
                    varying vec4 vShadowCoord;
                    varying vec2 vUv;
                    attribute float flag;
                    varying float vFlag;
                    varying float vTime;
                    varying float vInWater;
                    varying vec3 vNormal;

                    bool checkFlag(int bit) {
                        float rounded = floor(vFlag + 0.5); // Round the value
                        float divisor = float(bit);
                        return mod(floor(rounded / divisor), 2.0) >= 1.0; // Check if the bit is set
                    }

                    void main() {
                        vUv = uv;
                        vTime = data.time;
                        vInWater = data.in_water;
                        vFlag = flag; // Send flag to fragment shader
                        vColor = color;
                        vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                        vWorldPosition = worldPosition.xyz;
                        vNormal = normal;

                        // waves
                        vec3 modifiedPosition = position;
                        if (checkFlag(1)) {
                            // water waves
                            modifiedPosition.y -= 2./16.;
                            modifiedPosition.y += sin(position.x * 2.0 + data.time * 2.) * 0.0625;
                            modifiedPosition.y += cos(position.z * 2.0 + data.time * 2.) * 0.0625;
                        } else if (checkFlag(16)) {
                            // leaves movements
                            modifiedPosition.x += sin(position.x * 2.0 + data.time * 2.) * 0.0625;
                            modifiedPosition.x += cos(position.z * 2.0 + data.time * 2.) * 0.0625;
                            modifiedPosition.z += sin(position.x * 2.0 + data.time * 2.) * 0.0625;
                            modifiedPosition.z += cos(position.z * 2.0 + data.time * 2.) * 0.0625;
                        }

                        // vShadowCoord = data.shadowMatrix[0] * worldPosition;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(modifiedPosition - data.cameraOffset, 1.0);
                    }
                `,
                fragmentShader: `
                    varying vec2 vUv; // Receive UV from vertex shader
                    varying float vTime;
                    varying float vInWater;
                    varying vec3 vColor;
                    varying vec3 vWorldPosition;
                    varying vec4 vShadowCoord;
                    varying float vFlag;
                    varying vec3 vNormal; // Receive normal from vertex shader

                    struct Data {
                        vec3 cameraPosition;
                        vec3 cameraOffset;
                        vec3 fogColor;
                        float fogNear;
                        float fogFar;
                        float time;
                        float in_water;
                        sampler2D texture;
                        // mat4 shadowMatrix[NUM_DIR_LIGHTS];
                    };
                    uniform Data data;

                    // #include <shadowmap_pars_fragment>
                    // #include <packing>

                    const int FLAG_WATER_ANIMATED = 1;
                    const int FLAG_GRASS_BLOCK_SIDE = 2;
                    // const int UNUSED_FLAG_GRAVEL = 4;
                    // const int FLAG_ = 8;
                    const int FLAS_ANIMATED_LEAVES = 16;
                    const int FLAG_NO_CAN_TAKE_AO = 128;
                    const int FLAG_GRASS_COLOR = 64;

                    float hash(vec3 p) {
                        p = fract(p * 0.1031);
                        p += dot(p, p.yzx + 19.19);
                        return fract((p.x + p.y) * p.z);
                    }

                    bool checkFlag(int bit) {
                        float rounded = floor(vFlag + 0.5); // Round the value
                        float divisor = float(bit);
                        return mod(floor(rounded / divisor), 2.0) >= 1.0; // Check if the bit is set
                    }

                    void main() {

                        vec3 grass_color = vec3(84./256., 147./256., 42./256.);
                        vec3 water_color = vec3(15./256., 94./256., 156./256.);

                        float scale = 16.0;
                        vec3 pp = vWorldPosition;
                        if(checkFlag(8)) {
                            pp.y /= 2.0;
                        }
                        vec3 quantizedPos = floor(pp * scale + 1e-3);
                        float randomness = hash(quantizedPos);
                        vec3 finalColor = vColor;

                        vec2 uv = vUv;

                        if (checkFlag(FLAG_WATER_ANIMATED)) {
                            float frame_count = 32.0;
                            float frame_height = 1.0 / frame_count;
                            float current_frame = mod(floor(vTime * 16.), frame_count);
                            uv.y = uv.y - frame_height * current_frame;
                        }

                        vec4 texColor = texture2D(data.texture, uv);

                        if(texColor.a < 0.1) {
                            discard;
                        }

                        if(checkFlag(FLAS_ANIMATED_LEAVES)) {
                            texColor.rgb *= grass_color;
                        }
                        if(checkFlag(FLAG_WATER_ANIMATED)) {
                            texColor.rgb *= water_color;
                        }
                        if(checkFlag(FLAG_GRASS_COLOR)) {
                            texColor.rgb *= grass_color;
                        }

                        finalColor = texColor.rgb;

                        if(vInWater > 0.0) {
                            finalColor = mix(finalColor, water_color, 0.25);
                        }

                        if (checkFlag(FLAG_GRASS_BLOCK_SIDE)) {
                            // Top part of grass block
                            float quadY = mod(vWorldPosition.y, 1.0);
                            float rr = vec3(randomness).y * 0.2;
                            if (quadY > floor((0.7 + rr) * 16.) / 16.) {
                                // Change the color for the top part of the quad
                                finalColor = grass_color;
                                vec3 colorDeviation = vec3(randomness) * 0.2 - 0.1;
                                finalColor = clamp(finalColor + colorDeviation, 0.0, 1.0);
                            }
                        }

                        finalColor *= vColor;

                        if(checkFlag(FLAG_NO_CAN_TAKE_AO)) {
                            finalColor *= 1.2;
                        } else {
                            // Calculate normal based on position
                            vec3 normal = normalize(vNormal);
                            // Apply color change depending on the normal
                            if (normal.y > 0.5) {
                                finalColor *= 1.2; // Lighten the top
                            } else if (normal.y < -0.5) {
                                finalColor *= 0.5; // Darken the bottom
                            } else if (normal.z < 0.0) {
                                finalColor *= 0.7; // Darken the north
                            } else if (normal.z > 0.0) {
                                finalColor *= 0.7; // Lighten the south
                            } else {
                                finalColor *= 0.9; // Other sides
                            }
                        }

                        float distanceToCamera = length(vWorldPosition - data.cameraPosition);

                        distanceToCamera *= vInWater > 0.0 ? 6.0 : 1.0;

                        // Apply shadows
                        // float shadowFactor = texture2DShadow(shadowMap[0], vShadowCoord.xyz); // Added for shadow calculation
                        // finalColor *= shadowFactor; // Apply shadow factor

                        // Apply fog
                        // float fogFactor = smoothstep(data.fogNear, data.fogFar, distanceToCamera);
                        // vec3 foggedColor = mix(finalColor, vInWater > 0.0 ? water_color : data.fogColor, fogFactor);
                        vec3 foggedColor = finalColor;

                        float alpha = checkFlag(1) ? 0.75 : 1.0;
                        gl_FragColor = vec4(foggedColor, alpha);
                    }
                `
            })

        }

        async function createTexture() {
            const canvas = document.createElement('canvas')
            const ctx = canvas.getContext('2d')
            const keys = Object.keys(textures)
            // Load images and get their sizes
            const images = await Promise.all(keys.map(key => {
                const img = new Image()
                img.src = 'data:image/png;base64,' + textures[key].bin
                return new Promise(resolve => {
                    img.onload = () => resolve({ key, img, width: img.width, height: img.height })
                })
            }))
            // Determine the size of the atlas as the nearest power of two from the longest side of the textures
            const max_side = Math.max(...images.map(img => Math.max(img.width, img.height)))
            const atlas_size = Math.pow(2, Math.ceil(Math.log2(max_side)))
            canvas.width = atlas_size
            canvas.height = atlas_size
            // Place textures in the atlas
            let x_offset = 0
            let y_offset = 0
            let row_height = 0
            images.forEach(img => {
                if (x_offset + img.width > atlas_size) {
                    x_offset = 0
                    y_offset += row_height
                    row_height = 0
                }
                if (y_offset + img.height > atlas_size) {
                    throw new Error('Не удалось разместить все текстуры в атласе. Увеличьте размер атласа.')
                }
                ctx.drawImage(img.img, x_offset, y_offset, img.width, img.height)
                // Save UV coordinates
                textures[img.key].uv = [
                    x_offset / atlas_size,
                    1 - y_offset / atlas_size,
                    (x_offset + img.width) / atlas_size,
                    1 - (y_offset + img.width) / atlas_size
                ]
                x_offset += img.width
                row_height = Math.max(row_height, img.height)
            })
            // function downloadCanvas(canvas, filename = 'atlas.png') {
            //     const link = document.createElement('a')
            //     link.download = filename
            //     link.href = canvas.toDataURL('image/png')
            //     link.click()
            // }
            // downloadCanvas(canvas, 'texture-atlas.png')
            return new THREE.Texture(canvas)
        }

        function getPlayerPosition() { return player_controller.position }

        const _chunk_matrix_addr = new THREE.Vector3()
        function getChunkMatrixAddr(chunk_addr) {
            // globalThis.asdasdas ??= 0
            // if(globalThis.asdasdas++%1000==0)console.log(globalThis.asdasdas)
            const player_xyz = getPlayerPosition()
            const player_chunk = world.getChunkAddr(player_xyz.x, player_xyz.y, player_xyz.z, _ca_gcaddr)
            const player_matrix_x = ((player_chunk.x % matrix_side) + matrix_side) % matrix_side
            const player_matrix_z = ((player_chunk.z % matrix_side) + matrix_side) % matrix_side
            const x = (player_matrix_x + ((chunk_addr.x - player_chunk.x) % matrix_side) + matrix_side) % matrix_side
            const z = (player_matrix_z + ((chunk_addr.z - player_chunk.z) % matrix_side) + matrix_side) % matrix_side
            return _chunk_matrix_addr.set(x, 0, z)
        }

        function getChunk(chunk_addr, ignore_check_addr = false) {
            const { x, z } = getChunkMatrixAddr(chunk_addr)
            const chunk = matrix[z * matrix_side + x]
            if(chunk && (ignore_check_addr || chunk.addr.equals(chunk_addr))) {
                return chunk
            }
        }

        // Function to update coordinates
        function updateCoordinates(xyz) {
            const { x, y, z } = xyz
            if(Math.random() < 0.95) {
                localStorage.setItem('player_position', JSON.stringify({x, y, z}))
                localStorage.setItem('rotation', JSON.stringify({x: camera.rotation.x, y: camera.rotation.y, z: camera.rotation.z}))
            }
            if(frame % 5 === 0) {
                const chunk_coord = world.getChunkAddr(x, y, z)
                coords_el.textContent = `${x.toFixed(1)}, ${y.toFixed(1)}, ${z.toFixed(1)}\n`+
                    `Chunk: ${chunk_coord.x}/${chunk_coord.y}/${chunk_coord.z}\n`+
                    `Speed: ${walk_speed_counter.speed.toFixed(2)} km/h\n`+
                    `Render distance: ${render_distance}`
            }
        }

        function pseudoRandom(seed) {
            let value = (seed < 0 ? seed + 2147483647 : seed) % 2147483647
            return function() {
                value = (value * 16807) % 2147483647
                return value / 2147483647
            }
        }

        // 
        function applyBobView(position, elapsed_time) {
            const is_moving = move_forward || move_backward || move_left || move_right
            if(!player_controller.isGrounded) {
                elapsed_time = 0
            }
            const { frequency, amplitudeX, amplitudeY } = bob_зarams
            // If the player is moving, increase the time
            if (is_moving) {
                beft = 1
            } else {
                beft *= 0.9
            }
            bob_зarams.time += elapsed_time * 0.001 * beft
            const offset_y = Math.abs(Math.sin(bob_зarams.time * frequency)) * amplitudeY // Shift by Y (sharp vertical swing)
            const offset_x = Math.sin(bob_зarams.time * frequency * 0.5) * amplitudeX // Shift by X (smooth horizontal swing)
            return new THREE.Vector3(
                position.x + offset_x,
                position.y - offset_y,
                position.z
            )
        }

        function teleportTo(pos) {
            player_controller.position.copy(pos)
            player_controller.velocity.y = 0
        }

        function teleportRandomly() {
            const range = 1000
            teleportTo(new THREE.Vector3(
                Math.round(Math.random() * range - range / 2) + 0.5,
                Math.round(100 + Math.random() * 16),
                Math.round(Math.random() * range - range / 2) + 0.5,
            ))
        }

        function generateChunk(addr) {
            let /** @type {Chunk} */ chunk = getChunk(addr, true)
            chunk ||= new Chunk(world, chunk_size, seed)
            chunk.dispose()
            chunk.init(addr)
            chunk.generate()
            return chunk
        }

        function chunkAddrIsFarAway(center_addr, chunk_addr) {
            return chunk_addr.distanceToSquared(center_addr) > render_distance ** 2
        }

        function calcCircularRelativeIndex(i, g) {
            const n = matrix_side
            return ((i - g + n + render_distance) % n) - render_distance
        }

        // 
        const traverses = new VectorCollector()
        const _traverses_pos = new THREE.Vector3()
        function traverseSquareMatrix(center_x, center_z, size) {
            _traverses_pos.set(center_x, center_z, size)
            if(traverses.has(_traverses_pos)) {
                return traverses.get(_traverses_pos)
            }
            const cx = center_x
            const cz = center_z
            center_x = Math.floor(size / 2)
            center_z = Math.floor(size / 2)
            const result = []
            const directions = [
                [0, 1], // right
                [1, 0], // down
                [0, -1], // left
                [-1, 0] // up
            ]
            const visited = Array.from({ length: size }, () => Array(size).fill(false))
            let x = center_x
            let z = center_z
            let step = 1
            result.push([x, z])
            visited[x][z] = true // Помечаем начальную ячейку как посещённую
            while (result.length < size * size) {
                for (let d = 0; d < 4; d++) {
                    for (let i = 0; i < step; i++) {
                        x = (x + directions[d][0] + size) % size
                        z = (z + directions[d][1] + size) % size
                        if (!visited[x][z]) {
                            visited[x][z] = true
                            result.push([x, z])
                        }
                    }
                    if (d % 2 === 1) step++
                }
            }
            let resp = []
            result.filter((arr, i) => {
                let [x, z] = arr
                const sz2 = size / 2
                x = (((x - center_x) % size)) % size
                z = (((z - center_z) % size)) % size
                let dist = x ** 2 + z ** 2
                let ok = dist < (sz2 ** 2)
                arr = [x + cx, z + cz]
                if(ok) {
                    x = (x + cx + size) % size
                    z = (z + cz + size) % size
                    resp.push(z * size + x)
                }
                return ok
            })
            traverses.set(_traverses_pos, resp)
            return resp
        }

        // const traverses = new Map()
        // function traverseCone(center_x, center_y, size, yaw_deg, tilt_deg, fov_deg) {
        //     yaw_deg = Math.round((((yaw_deg % 360) + 360) % 360) / 10) * 10
        //     tilt_deg = Math.abs(Math.round(tilt_deg / 10) * 10)
        //     fov_deg = Math.round(Math.min(Math.max(fov_deg, 0), 180) / 5) / 5
        //     const key = `${center_x},${center_y},${size},${yaw_deg},${tilt_deg},${fov_deg}`
        //     if(traverses.has(key)) {
        //         return traverses.get(key)
        //     }
        //     // Преобразование градусов в радианы
        //     const angle_rad = yaw_deg * Math.PI / 180
        //     const tilt_rad = tilt_deg * Math.PI / 180
        //     const half_fov_rad = (fov_deg / 2) * Math.PI / 180
        //     // Направляющий вектор взгляда
        //     const dir_x = Math.cos(tilt_rad) * Math.cos(angle_rad)
        //     const dir_y = Math.cos(tilt_rad) * Math.sin(angle_rad)
        //     const dir_z = -Math.sin(tilt_rad); // Отрицательный, так как ось Z направлена вверх
        //     // Высота наблюдателя над плоскостью
        //     const h = 1 // Можно взять любое положительное число
        //     const cells = []
        //     for (let x = 0; x < size; x++) {
        //         for (let z = 0; z < size; z++) {
        //             // Вектор от наблюдателя к клетке
        //             const vec_x = x - center_x
        //             const vec_y = z - center_y
        //             const vec_z = -h
        //             // Длина вектора к клетке
        //             const vec_length = Math.sqrt(vec_x * vec_x + vec_y * vec_y + vec_z * vec_z)
        //             // Нормализуем вектор к клетке
        //             const norm_vec_x = vec_x / vec_length
        //             const norm_vec_y = vec_y / vec_length
        //             const norm_vec_z = vec_z / vec_length
        //             // Косинус угла между направляющим вектором и вектором к клетке
        //             const cos_theta = dir_x * norm_vec_x + dir_y * norm_vec_y + dir_z * norm_vec_z
        //             // Угол между векторами
        //             const theta = Math.acos(Math.min(Math.max(cos_theta, -1), 1)) // Ограничиваем cos_theta в диапазоне [-1, 1]
        //             // Расстояние в плоскости XY
        //             const distance_xy = Math.sqrt((x - center_x) ** 2 + (z - center_y) ** 2)
        //             // Проверяем, находится ли клетка внутри конуса обзора
        //             const in_fov = theta <= half_fov_rad
        //             // Вычисляем приоритет
        //             const priority = distance_xy * (1 - cos_theta)
        //             cells.push({
        //                 x: x,
        //                 z: z,
        //                 flat_index: z * size + x,
        //                 priority: priority,
        //                 in_fov: in_fov,
        //                 distance: distance_xy
        //             })
        //         }
        //     }
        //     // Сортируем клетки по приоритету
        //     cells.sort(function(a, b) {
        //         if (a.in_fov && b.in_fov) {
        //             return a.priority - b.priority // Меньший приоритет имеет больший приоритет в обходе
        //         } else if (a.in_fov) {
        //             return -1; // Клетки внутри FOV идут раньше
        //         } else if (b.in_fov) {
        //             return 1
        //         } else {
        //             return a.priority - b.priority
        //         }
        //     })
        //     // Извлекаем координаты из отсортированного списка
        //     // const coords = cells.map(cell => [cell.x, cell.y])
        //     const result = cells.map(cell => cell.flat_index)
        //     traverses.set(key, result)
        //     console.log(traverses.size)
        //     return result
        // }

        function chunkWorks() {
            const player_xyz = getPlayerPosition()
            const { x: player_chunk_x, y: player_chunk_y, z: player_chunk_z } = world.getChunkAddr(player_xyz.x, player_xyz.y, player_xyz.z)
            const player_matrix_x = ((player_chunk_x % matrix_side) + matrix_side) % matrix_side
            const player_matrix_z = ((player_chunk_z % matrix_side) + matrix_side) % matrix_side
            const cell_chunk_addr = new THREE.Vector3()
            let max_generates = 3
            // let max_generates = 2
            // Получаем углы поворота в радианах
            // const euler = new THREE.Euler().setFromQuaternion(camera.quaternion, 'YXZ')
            // const yaw = (THREE.MathUtils.radToDeg(euler.y) + 360) % 360
            // const tilt = THREE.MathUtils.radToDeg(euler.x)
            // const traverse = traverseCone(player_matrix_x, player_matrix_z, matrix_side, yaw, Math.abs(tilt), 120)
            const traverse = traverseSquareMatrix(player_matrix_x, player_matrix_z, matrix_side)
            for(let i = 0; i < traverse.length; i++) {
                const ti = traverse[i]
                const chunk = matrix[ti]
                const x = ti % matrix_side
                const z = Math.floor(ti / matrix_side)
                cell_chunk_addr.set(
                    player_chunk_x + calcCircularRelativeIndex(x, player_matrix_x),
                    player_chunk_y,
                    player_chunk_z + calcCircularRelativeIndex(z, player_matrix_z),
                )
                if(!chunk || !chunk.addr.equals(cell_chunk_addr)) {
                    matrix[ti] = generateChunk(cell_chunk_addr)
                    if(--max_generates == 0) break
                } else if(chunk.quads == 0 && chunk.neighbours_mask == 15) {
                    const neib_nx = getChunk(cell_chunk_addr.clone().add({x: -1, y: 0, z: 0}))
                    const neib_px = getChunk(cell_chunk_addr.clone().add({x: 1, y: 0, z: 0}))
                    const neib_nz = getChunk(cell_chunk_addr.clone().add({x: 0, y: 0, z: -1}))
                    const neib_pz = getChunk(cell_chunk_addr.clone().add({x: 0, y: 0, z: 1}))
                    if(neib_nx && neib_px && neib_nz && neib_pz) {
                        chunk.makeVertices()
                        if(--max_generates == 0) break
                    }
                }
            }
        }

        const walk_speed_counter = {
            total_distance: 0,
            start_time: 0,
            speed: 0,
            prev_pos: null,
            add(pos) {
                if(this.prev_pos) {
                    this.total_distance += pos.distanceTo(this.prev_pos)
                    const elapsed_time = (performance.now() - this.start_time) / 1000
                    this.speed = (this.total_distance / elapsed_time * 3.6)
                    if(elapsed_time > 0.2) {
                        this.start_time = performance.now()
                        this.total_distance = 0
                    }
                    this.prev_pos.copy(pos)
                } else {
                    this.start_time = performance.now()
                    this.prev_pos = pos.clone()  
                }
            }
        }

        function animate() {

            pnw1 ??= performance.now()
            stats.begin()
            const elapsed = Math.min(performance.now() - pnw1, 32)
            pnw1 = performance.now()
            frame++

            const prev_player_pos = player_controller.position.clone()

            if(spectator_mode) {
                const speed = 0.025 * speed_mul
                velocity.multiplyScalar(0.95)
                if (move_forward) velocity.z += speed
                if (move_backward) velocity.z -= speed
                if (move_left) velocity.x += speed
                if (move_right) velocity.x -= speed
                if (move_up) velocity.y += speed
                if (move_down) velocity.y -= speed
                // Calculate the direction of movement relative to the camera
                direction.set(0, 0, 0)
                camera.getWorldDirection(direction)
                direction.y = 0 // Only move in the XZ plane
                direction.normalize()
                const right = new THREE.Vector3().crossVectors(up, direction).normalize()
                const move = new THREE.Vector3()
                move.addScaledVector(direction, velocity.z)
                move.addScaledVector(right, velocity.x)
                move.y += velocity.y
                player_controller.position.add(move)
            } else {
                player_controller.update(elapsed)
            }

            const move = prev_player_pos.sub(player_controller.position)
            camera.position.sub(move)
            // camera.position.copy(applyBobView(camera.position, elapsed))
            acc_shift.add(move)
            acc_shift.y = 0

            if(acc_shift.length() > 1024) {
                camera.position.add(acc_shift)
                let p = performance.now()
                for(let i = 0; i < matrix.length; i++) {
                    const chunk = matrix[i]
                    if(chunk) {
                        for(const mesh of Object.values(chunk.meshes)) {
                            if(mesh) mesh.mesh.position.add(acc_shift)
                        }
                    }
                }
                acc_shift.set(0, 0, 0)
                console.log('Shift:', performance.now() - p)
            }

            updateCoordinates(player_controller.position) // Update coordinates panel

            const eye_block_pos = camera.position.clone()
            eye_block_pos.y += player_height
            const block_in_camera = world.getBlock(...eye_block_pos.toArray())

            for(const mat of Object.values(shader_materials)) {
                const cam_pos = applyBobView(camera.position, elapsed)
                mat.uniforms.data.value.cameraPosition.copy(cam_pos)
                mat.uniforms.data.value.time = performance.now() / 1000
                mat.uniforms.data.value.in_water = block_in_camera?.id == 4 ? 1 : 0
                mat.uniforms.data.value.cameraOffset.y = player_height
                mat.uniforms.data.value.fogNear = (render_distance * chunk_size.x) * 0.8
                mat.uniforms.data.value.fogFar = render_distance * chunk_size.x * 0.9
            }

            chunkWorks()

            renderer.render(scene, camera)
            walk_speed_counter.add(camera.position)
            stats.end()

            requestAnimationFrame(animate)

        }

        function printStat() {
            console.log(`%cQuads: %c${scene_info.quads.toLocaleString()}, ` +
                        `%cMemory usage: %c${(world.getMemoryUsage() / (1024 * 1024)).toFixed(2)}MB, `,
                'font-weight: bold;', 'color: blue;', 
                'font-weight: bold;', 'color: green;')
            console.table(stata)
        }

        createTexture().then(texture => {

            shader_materials = {
                regular: createShaderMaterial(texture),
                transparent: createShaderMaterial(texture, { side: THREE.DoubleSide, transparent: true, depthWrite: false, depthTest: true, blending: THREE.NormalBlending}),
                doubleside: createShaderMaterial(texture, { side: THREE.DoubleSide }),
            }

            console.log('Map:', render_distance * chunk_size.x, 'x', render_distance * chunk_size.z)

            stats = new Stats()
            stats.showPanel(0) // 0: FPS, 1: MS, 2: MB
            document.body.appendChild(stats.domElement)

            document.body.appendChild(renderer.domElement)

            addListeners()
            animate()

        })

    </script>
</body>
</html>