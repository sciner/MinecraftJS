<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Cube</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #87ceeb; }
        canvas { display: block; }
        .f3-line { margin-bottom: .2em; text-shadow: 0 0 10px #333; }
        .key { display: inline-block; border-radius: 4px; padding: .1em .5em; background-color:dimgrey; border: 2px solid #fff; }
        .coords { position: absolute; top: 10px; right: 10px; color: white; font-size: 16px; font-family: monospace; }
        #loading { position: absolute; color: white; font-weight: bold; text-shadow: 0 0 10px #333; z-index: -1; font-family: 'Courier New', Courier, monospace; left: 50%; top: 50%; transform: translate(-50%, -50%);}
    </style>
    <script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r110/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r110/examples/js/controls/PointerLockControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/simplex-noise@2.4.0/simplex-noise.min.js"></script>
</head>
<body>

    <div id="loading">Loading...</div>

    <script type="module">

        import Stats from 'https://cdnjs.cloudflare.com/ajax/libs/stats.js/r17/Stats.min.js'

        class PlayerController {

            constructor(world, gravity = 9.8, inertia = 0.99, start_position) {
                this.world = world
                this.gravity = gravity
                this.inertia = inertia
                this.position = new THREE.Vector3(start_position.x, start_position.y, start_position.z) // Текущая позиция игрока
                this.velocity = { x: 0, y: 0, z: 0 } // Скорость игрока
                this.isGrounded = false // Находится ли игрок на земле
                this.jumpForce = 5 // Сила прыжка
            }

            update(elapsed_ms) {
                const elapsed_seconds = elapsed_ms / 1000
                const margin = 0.2 // Минимальное расстояние до блока

                // Проверяем блок под игроком
                const blockBelow = this.world.getBlockAt(
                    this.position.x,
                    this.position.y - 0.5, // Слегка ниже текущей позиции
                    this.position.z
                )
                this.block_below = blockBelow

                // Устанавливаем флаг isGrounded
                this.isGrounded = blockBelow !== 0

                // Применяем гравитацию
                if (!this.isGrounded) {
                    this.velocity.y -= this.gravity * elapsed_seconds
                }

                // Рассчитываем движение
                let moveVector = { x: 0, z: 0 }
                if (move_forward) {
                    const dir = new THREE.Vector3()
                    camera.getWorldDirection(dir)
                    moveVector.x += dir.x
                    moveVector.z += dir.z
                }
                if (move_backward) {
                    const dir = new THREE.Vector3()
                    camera.getWorldDirection(dir)
                    moveVector.x -= dir.x
                    moveVector.z -= dir.z
                }
                if (move_left) {
                    const right = new THREE.Vector3().crossVectors(new THREE.Vector3(0, 1, 0), camera.getWorldDirection(new THREE.Vector3())).normalize()
                    moveVector.x += right.x
                    moveVector.z += right.z
                }
                if (move_right) {
                    const right = new THREE.Vector3().crossVectors(new THREE.Vector3(0, 1, 0), camera.getWorldDirection(new THREE.Vector3())).normalize()
                    moveVector.x -= right.x
                    moveVector.z -= right.z
                }

                // Нормализуем движение для предотвращения ускорения при диагональном движении
                const length = Math.sqrt(moveVector.x ** 2 + moveVector.z ** 2)
                if (length > 0) {
                    moveVector.x /= length
                    moveVector.z /= length
                }

                // Применяем движение
                const movement_speed = 100
                this.velocity.x += moveVector.x * elapsed_seconds * movement_speed
                this.velocity.z += moveVector.z * elapsed_seconds * movement_speed

                // Применение инерции
                this.velocity.x *= this.inertia
                this.velocity.z *= this.inertia

                // Рассчитываем новую позицию
                let new_pos = new THREE.Vector3(
                    this.position.x + this.velocity.x * elapsed_seconds,
                    this.position.y + this.velocity.y * elapsed_seconds,
                    this.position.z + this.velocity.z * elapsed_seconds
                )

                // Проверяем столкновения с миром, учитывая margin
                const block_at_new_pos_x = this.world.getBlockAt(
                    new_pos.x + Math.sign(this.velocity.x) * margin, // Проверка с учетом направления
                    this.position.y,
                    this.position.z
                )

                if (block_at_new_pos_x !== 0) {
                    // Блокируем движение по X
                    this.velocity.x = 0
                    new_pos.x = this.position.x
                }

                const block_at_new_pos_z = this.world.getBlockAt(
                    this.position.x,
                    this.position.y,
                    new_pos.z + Math.sign(this.velocity.z) * margin // Проверка с учетом направления
                )

                if (block_at_new_pos_z !== 0) {
                    // Блокируем движение по Z
                    this.velocity.z = 0
                    new_pos.z = this.position.z
                }

                // Проверяем вертикальное столкновение
                const block_at_new_pos_y = this.world.getBlockAt(
                    this.position.x,
                    new_pos.y,
                    this.position.z
                )

                if (block_at_new_pos_y !== 0) {
                    if (this.velocity.y < 0) {
                        this.isGrounded = true // Если падаем, то считаем, что игрок на земле
                    }
                    this.velocity.y = 0
                    new_pos.y = this.position.y
                }

                // Обновляем позицию
                this.position = new_pos
            }

            // Прыжок
            jump() {
                if (this.isGrounded) {
                    this.velocity.y = this.jumpForce
                    this.isGrounded = false
                }
            }

            }

        class World {

            /**
            * Хранит битовый массив мира (для определения занятых солид блоками)
            * @param {Uint8Array} worldSizeInChunks
            **/
            blocks_bits

            constructor(chunk_size, world_size_in_chunks) {
                this.chunk_size = chunk_size
                this.world_size_in_chunks = world_size_in_chunks
                this.world_size = {
                    x: this.world_size_in_chunks.x * this.chunk_size.x,
                    y: this.world_size_in_chunks.y * this.chunk_size.y,
                    z: this.world_size_in_chunks.z * this.chunk_size.z
                }
                // Массив, уменьшенный в 8 раз (байтовый массив)
                const total_size = this.world_size.x * this.world_size.y * this.world_size.z
                this.blocks_bits = new Uint8Array(Math.ceil(total_size / 8))
            }

            getMemoryUsage() {
                return this.blocks_bits.length
            }

            getBlockAt(x, y, z) {
                x = Math.floor(x)
                y = Math.floor(y)
                z = Math.floor(z)
                if (!this.isInBounds(x, y, z)) return 0
                const index = this.getIndex(x, y, z)
                const byteIndex = Math.floor(index / 8)
                const bitIndex = index % 8
                return (this.blocks_bits[byteIndex] >> bitIndex) & 1
            }

            setBlockAt(x, y, z, value) {
                if (!this.isInBounds(x, y, z)) return 0
                const index = this.getIndex(x, y, z)
                const byte_index = Math.floor(index / 8)
                const bit_index = index % 8
                if (value) {
                    this.blocks_bits[byte_index] |= (1 << bit_index)
                } else {
                    this.blocks_bits[byte_index] &= ~(1 << bit_index)
                }
            }

            getIndex(x, y, z) {
                const ws = this.world_size
                return x + y * ws.x + z * ws.x * ws.y
            }

            checkBlockAt(x, y, z) {
                if (!this.isInBounds(x, y, z)) return 0
                const index = this.getIndex(x, y, z)
                const byte_index = Math.floor(index / 8)
                const bit_index = index % 8
                return (this.blocks_bits[byte_index] >> bit_index) & 1
            }

            checkNeighbors(x, y, z, neighbors) {
                let cnt = 0
                for (let i = 0; i < 6; i++) {
                    const nx = x + directions[i].x
                    const ny = y + directions[i].y
                    const nz = z + directions[i].z
                    // Проверка, есть ли сосед в пределах границ мира
                    neighbors[i] = this.checkBlockAt(nx, ny, nz)
                    cnt += neighbors[i]
                }
                return cnt !== 6
            }

            isInBounds(x, y, z) {
                return x >= 0 && x < this.world_size.x &&
                    y >= 0 && y < this.world_size.y &&
                    z >= 0 && z < this.world_size.z
            }

            _calcAO(x, y, z, ax, ay, az, fix) {
                let ao_value = 1
                let side1, side2
                const cornerBlock = this.getBlockAt(x + ax, y + ay, z + az)
                switch(fix) {
                    case 0: {
                        side1 = this.getBlockAt(x + ax, y + ay, z)
                        side2 = this.getBlockAt(x + ax, y, z + az)
                        break
                    }
                    case 1: {
                        side1 = this.getBlockAt(x + ax, y + ay, z)
                        side2 = this.getBlockAt(x, y + ay, z + az)
                        break
                    }
                    case 2: {
                        side1 = this.getBlockAt(x + ax, y, z + az)
                        side2 = this.getBlockAt(x, y + ay, z + az)
                        break
                    }
                }
                if(side1) ao_value -= 0.25
                if(side2) ao_value -= 0.25
                if(cornerBlock) ao_value -= 0.25
                return ao_value
            }

            calculateAO(x, y, z, i, p) {
                let ao_value = 1
                if(i != 1) {
                    const index = ao_indexes[p]
                    const a = ao_table[i]
                    const b = a.moves[index]
                    ao_value = this._calcAO(x, y, z, b[0], b[1], b[2], a.fix)
                }
                const ao_strenght = 0.8
                if(ao_value < 1 && ao_strenght != 1) {
                    ao_value *= ao_strenght
                }
                return ao_value
            }

        }

        class CubesMeshBuilder {

            constructor(world, reserve_faces = 1000, shader_material) {
                const geometry = new THREE.BufferGeometry()
                const material = shader_material // new THREE.MeshBasicMaterial({ vertexColors: true })
                this.world              = world
                this.reserve_faces      = reserve_faces // Начальный резерв кубов
                this.face_size          = 6 // Полигонов на куб
                this.vertex_size        = 3 // Координаты x, y, z
                this.uvs_size           = 2 // Координаты x, y, z
                this.color_size         = 3 // Цветовые компоненты RGB
                this.resize_factor      = 1.5 // Коэффициент увеличения резервной памяти
                this.flag_size          = 1 // Размер для кастомного флага
                this.vertices           = new Float32Array(this.reserve_faces * this.face_size * this.vertex_size)
                this.uvs                = new Float32Array(this.reserve_faces * this.face_size * this.uvs_size)
                this.colors             = new Float32Array(this.reserve_faces * this.face_size * this.color_size)
                this.flags              = new Float32Array(this.reserve_faces * this.face_size * this.flag_size) // массив флагов
                this.used_faces         = 0 // Количество добавленных кубов
                this.mesh               = new THREE.Mesh(geometry, material)
                this.mesh.castShadow    = true
                this.mesh.receiveShadow = true
            }

            // Добавление куба в менеджер
            addCube(x, y, z, block, neighbours) {

                x += 0.5
                y += 0.5
                z += 0.5

                if (this.used_faces >= this.reserve_faces) {
                    this._resizeBuffers()
                }

                let draw_faces_count = 6
                if(neighbours[0]) draw_faces_count--
                if(neighbours[1]) draw_faces_count--
                if(neighbours[2]) draw_faces_count--
                if(neighbours[3]) draw_faces_count--
                if(neighbours[4]) draw_faces_count--
                if(neighbours[5]) draw_faces_count--
                if(draw_faces_count == 0) return

                const hs = 1 / 2 // half_size
                const vertices_index = this.used_faces * this.face_size * this.vertex_size
                const uvs_index = this.used_faces * this.face_size * this.uvs_size
                const colorIndex = this.used_faces * this.face_size * this.color_size
                const flagIndex = this.used_faces * this.face_size * this.flag_size

                // Запись позиций напрямую
                const vertices = this.vertices
                const uvs = this.uvs
                let vi = vertices_index
                let ui = uvs_index

                for (let fi = 0; fi < 6; fi++) {
                    if (!neighbours[fi]) {
                        const face = block[fi]
                        const uv = face.texture?.uv ?? [0, 0, 0, 0]
                        const { vertices: faceVertices, uv: faceUV } = face_offsets[fi]
                        for (let i = 0; i < faceVertices.length; i += 3) {
                            vertices[vi++] = x + hs * faceVertices[i]
                            vertices[vi++] = y + hs * faceVertices[i + 1]
                            vertices[vi++] = z + hs * faceVertices[i + 2]
                            // Добавляем UV, масштабируя их по значениям u, v, u2, v2
                            uvs[ui++] = faceUV[(i / 3) * 2] === 0 ? uv[0] : uv[2]
                            uvs[ui++] = faceUV[(i / 3) * 2 + 1] === 0 ? uv[1] : uv[3]
                        }
                        scene_info.quads++
                    }
                }

                // Запись цветов напрямую
                const colors = this.colors
                const flags = this.flags
                let ci = colorIndex
                let fi = flagIndex

                for (let i = 0; i < 6; i++) {
                    if (neighbours[i]) continue // Если грань не выбрана, пропускаем
                    // Если грань выбрана, записываем цвета
                    const face = block[i]
                    const flag = face.flag || 0
                    let [r, g, b] = face.color
                    for(let p = 0; p < 6; p++) {
                        const ao_value = this.world.calculateAO(x - 0.5, y - 0.5, z - 0.5, i, p)
                        colors[ci++] = ao_value // * r
                        colors[ci++] = ao_value // * g
                        colors[ci++] = ao_value // * b
                        flags[fi++] = flag
                    }
                }

                this.used_faces += draw_faces_count
            }

            // 
            addPlant(x, y, z, size, block) {
                const { color, flag, texture } = block[0]

                x += 0.5 + Math.random() * 0.2 - 0.1
                y += 0.5
                z += 0.5 + Math.random() * 0.2 - 0.1

                if (this.used_faces >= this.reserve_faces) {
                    this._resizeBuffers()
                }

                const hs = size / 2 // half_size
                const vertices_index = this.used_faces * this.face_size * this.vertex_size
                const uvs_index = this.used_faces * this.face_size * this.uvs_size
                const color_index = this.used_faces * this.face_size * this.color_size
                const flag_index = this.used_faces * this.face_size * this.flag_size

                const vertices = this.vertices
                const uvs = this.uvs
                let vi = vertices_index
                let ui = uvs_index

                const uv = texture?.uv ?? [0, 0, 0, 0]

                grass_planes.forEach((plane) => {
                    for (let i = 0; i < plane.length; i += 3) {
                        vertices[vi++] = x + hs * plane[i]
                        vertices[vi++] = y + hs * plane[i + 1]
                        vertices[vi++] = z + hs * plane[i + 2]
                    }
                    // Инвертируем v-координаты
                    uvs[ui++] = uv[0]
                    uvs[ui++] = uv[3] // Инверсия
                    uvs[ui++] = uv[2]
                    uvs[ui++] = uv[3] // Инверсия
                    uvs[ui++] = uv[2]
                    uvs[ui++] = uv[1] // Инверсия
                    uvs[ui++] = uv[0]
                    uvs[ui++] = uv[3] // Инверсия
                    uvs[ui++] = uv[2]
                    uvs[ui++] = uv[1] // Инверсия
                    uvs[ui++] = uv[0]
                    uvs[ui++] = uv[1] // Инверсия

                    scene_info.quads++
                    this.used_faces++
                })

                // Запись цветов напрямую
                const colors = this.colors
                const flags = this.flags
                let ci = color_index
                let fi = flag_index

                for (let i = 0; i < 12; i++) {
                    colors[ci++] = color[0]
                    colors[ci++] = color[1]
                    colors[ci++] = color[2]
                    flags[fi++] = flag
                }

            }

            // Обновление меша из данных
            updateMesh() {
                const geometry = this.mesh.geometry
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(this.vertices.slice(0, this.used_faces * this.face_size * this.vertex_size), 3))
                geometry.setAttribute('uv', new THREE.Float32BufferAttribute(this.uvs.slice(0, this.used_faces * this.face_size * this.uvs_size), 2))
                geometry.setAttribute('color', new THREE.Float32BufferAttribute(this.colors.slice(0, this.used_faces * this.face_size * this.color_size), 3))
                geometry.setAttribute('flag', new THREE.Float32BufferAttribute(this.flags.slice(0, this.used_faces * this.face_size * this.flag_size), 1))
                geometry.computeVertexNormals()
            }

            // Увеличение памяти для буферов
            _resizeBuffers() {
                this.reserve_faces = Math.floor(this.reserve_faces * this.resize_factor)
                const new_vertices = new Float32Array(this.reserve_faces * this.face_size * this.vertex_size)
                const new_uvs = new Float32Array(this.reserve_faces * this.face_size * this.uvs_size)
                const new_colors = new Float32Array(this.reserve_faces * this.face_size * this.color_size)
                const new_flags = new Float32Array(this.reserve_faces * this.face_size * this.flag_size)
                new_vertices.set(this.vertices)
                new_uvs.set(this.uvs)
                new_colors.set(this.colors)
                new_flags.set(this.flags)
                this.vertices = new_vertices
                this.uvs = new_uvs
                this.colors = new_colors
                this.flags = new_flags
            }

            getMemoryUsage() {
                const total_size = (this.reserve_faces * this.face_size * this.vertex_size * Float32Array.BYTES_PER_ELEMENT) +
                                (this.reserve_faces * this.face_size * this.color_size * Float32Array.BYTES_PER_ELEMENT)
                return total_size // Возвращает в мегабайтах
            }

            }

        const textures = {
            dirt: {bin: 'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQBAMAAADt3eJSAAAAFVBMVEW5hVyHh4eWbEpsbGx0WER5VTpZPSnqDkA3AAAAbklEQVR42hXLwQnDQAwEwOVA7uDyNgq6AtJD/mLD6m0Muv5LCJ7/YES6OhNsvjLGhpXJtA1vW+nMQJy31o+Ncu4uJUwzDSQE13I5giyGGuxqCQTTxnX4RPDkJ+5ChZskgPp6HemIqwp8+ojp8voDZ2EdYwBe7AYAAAAASUVORK5CYII='},
            bedrock: {bin: 'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAAAAAA6mKC9AAAAcElEQVR42jWPMQ0DQBSFvpazgBgEPFHYbdKmCwth4AZgM0E8ttai9pDjwQNCzZ1tPlMAvEcAwmrjUFF4X3A190e8U/EnkXkrQVeruq8TmUC7LVY8qsE9FVy51TuBCQsAby2fwMPVbcI/An9zNdwD9wFD0lUf95ycGwAAAABJRU5ErkJggg=='},
            gravel: {bin: 'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQBAMAAADt3eJSAAAAGFBMVEWwrq6xoqKXl5eWjo6JgX6Bf39ya2lkW1tYVrIwAAAAe0lEQVR42g3GwRECIQwF0D/MWIENODtk7YC7DOFulqQANFCAsvXrOz18Uxd3MZBptVUydNZCbf+HueveFO9ncp3CWK+zUCBD/Wjo8VRsHKkNjYjkra6bo41gxMbwHKcY36ExXwaLwVjlkTZBmdIONULmMo4yM/zqyuz+A5MJJSnE6Mt8AAAAAElFTkSuQmCC'},
            oak_leaves: {bin: 'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQBAMAAADt3eJSAAAAD1BMVEUAAAC5vLmYmZh3dXdoZGjJX6haAAAAAXRSTlMAQObYZgAAAGlJREFUeNoFgAERwyAMAD8pAtJ0AgIYaAEBbI1/TTtSNOaPiyCHDqkwtVvIia7tHzB6p1IatFtW8gazuB93e1j7tBwy8PJtR4+OkW+0cDR2exThSqQeASMalo9QZe2iV8XcmbgRp5W8Rf/WMg1MmmHulQAAAABJRU5ErkJggg=='},
            oak_log: {bin: 'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQBAMAAADt3eJSAAAAElBMVEWYeEmRcUJ0WjZfSitMPSY4Kxj0FtFUAAAAaklEQVR42hXGQRHDMAwEQI1VBJINwLoTgLgEaiHohD+YOPtaoaXl3BBqas6C5DeVPBkgkOXSkVDQxKpT+8kqX2ZvbrvCYcJ/XHA3iV8sdLslJhI84UnLVvIJH5qxpJXRGSG2Y5D7TXXGxgPEiBE7ybf/RAAAAABJRU5ErkJggg=='},
            oak_log_top: {bin: 'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQBAMAAADt3eJSAAAAG1BMVEXCnWK4lF+vj1WfhE2WdEF+Yjd0WjZfSitMPSYsJcj4AAAAf0lEQVR42hXJsQ3CMBAF0H/OFxGNfZHoI8gqzMIMjMFCVGwAdQCxgO8EHZKP8NrHY0vhRY3rk8BG62n7aoHpQnzPKtEpxbcAXFksjZ6vQh8+D2StRA0pVjfEQvECFYinqtD0PbX6L2szIGCBBYJLdTsFcCPm4Z5TXbE/SHgp/gPG/zIQFSN2ggAAAABJRU5ErkJggg=='},
            stone: {bin: 'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAAAAAA6mKC9AAAAZElEQVR42jWNsQ0AMQjEGJcB3HsEr/xSkncBOgkfUyXIguoo4mEXGdkFFvBdlGmpwKCAWIWOeYFladCK4n2BXZZn6vR3dsXRfLnKWfFoXmtUrX81AiboaZ9u4I1G8KdqPICl6AdyLn2NfcJFIAAAAABJRU5ErkJggg=='},
            stone_bricks: {bin: 'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQBAMAAADt3eJSAAAAFVBMVEWcmZyLiYt/f394dnhqbWpjY2NaWVo/4AZ+AAAAbUlEQVR42hWJsREDIRDEuC3A7F7gmKMDXK5bIHFLXwHwDWBeo0AzAtOD3rhd8qqEnSUOEqZh29cTMZA1wb0iXy+iIeQNhKpqSBn923/9gCbnOhcXSWMh8jLavTaMeR4dCk97lQlZ4ic8IKlUSX8TNSDr6TM/jQAAAABJRU5ErkJggg=='},
            sand: {bin: 'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQBAMAAADt3eJSAAAAElBMVEXt68vn5Lvj27Daz6PVxJbRuopf1Q47AAAAZklEQVR42gVAwQ3CMBCzQPyRukEcBqjP/dNzWAC6/ywIm0y2GrH72h47eJ1VdqDpOdqF3FuqCK7BzApOv7N+Nlyx126E+nQYbKl1uCYOWcVLWMWMlSDdfnIJ5EtSBdKN5LdADrnIP0wTGY7btIheAAAAAElFTkSuQmCC'},
            grass_block_top: {bin: 'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAADAFBMVEU3Wx5IeCg2Wh4xUhs1WB0vTho0Vh06YSA3XB8zVRwyUxwyVBw+ZyIpRRc0Vx03XB47YiE4XR84Xh8vTxowUBo+aCI9ZiIzVhw8ZCEuTRkxURs1WR07YiBAaiMsSRhDcCUrSRg1WR4wURs/aiNAayNFciYrSBg/aSMuThosShgwTxo5XyA5YCBDbyUuTBk8ZSFCbiRDcSVHdictShktTBktSxk7YyFGdicAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEdUADQdjt2OxUAAAAAAAABAAAAAABzhKHtiHcAAE8AAAAAADAAAAAAAAAAAABzhPgAAHcAAAAAAAAAAAAAAAB0AAB2OxYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB4gBTQOHcAAIMAfQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGQAAADIAAAAh/UAADYAAAAQAAAANgCDs1jQOAC4AIMAh/V9AAAAAADEAAAAT+10PTau2XcAd3UAAAAAAAAAAAAAAAAAAAAAAADvRADOvYB2LAhP7mgJKQC3diwAAAAAAAAAAACewAB2LAkAAGAABQCAAAAAAAAQAIAAAMBwAAAAAAYAAAAAAwAAAAAAAAB6AHjQOACAAIMAT+4AAAAAAAA4AAAAg9AAAACzYAAAd3cAAAAAAAAAAAAAAAAAAAAAABgAAAAIAAAAT+4AAEAAAABYAAAAT+6o1rAAAAkMAH3zqL15AAAAAWJLR0SL8m9H4AAAAAlwSFlzAAALEwAACxMBAJqcGAAAAOFJREFUGNMNzMligjAUAMDHSwJkaSBhDUgR0ILBKhVr///P6nEuAxAgIZSFUcyFVB8akjA1NrM5K0oMQlFBrV0jZdvCQXXiM+vhSLgZrEM2akMr5aAeu3E6yen8lal5kRqsvZQ+TlaRyPHyNizXssWRs0Z8T4MyFKiIqvZ2b0wnPE1ZAWrt58l3123OkWC0gMl/dGjnTAxY6I16WCNT5r3Gx65GKt9H05HaNCgNhs+NOQ5n47kdyC8fuDuUuwGvjuisD16o1lSqE9Svx3ObAZckEUVU7UBiKe8WUP/diqaV0T9QvxT8vFJhIAAAAABJRU5ErkJggg=='},
            water_still: {bin: 'iVBORw0KGgoAAAANSUhEUgAAABAAAAIABAMAAAB5lPHgAAAAJ1BMVEX////5+fnY2NjW1tbV1dXT09PS0tLPz8/Ozs7CwsK4uLiurq6lpaUTLc7BAAAADXRSTlO0tLS0tLS0tLS0tLS0frXQ3wAABWRJREFUeNqN2D2OHLcSB/AC3pO8/XyCd4B3hHcE5+Ng1qY62UQCBpsosAwoE+AvbDZJD1BbSmXA2MTJGqD/dYOqQ3lYZH/M9IxsBgOCPWz+UF1kk00CN+DwHbkDcHcqP2BxUs8CBsihbm4gVwhEnQSl3Hb0TY9SZ6J0l3KWZ/Io5hR9MkDemqhdiUsAq5YWy/ReKePr/0IAegrP8OPKg5VHyN0E4k4YPd8Wj4bnZoe1ByuPn3k800PxbDoIhPrwPP8rPLb25PBg5VEAh442T3gKz4t0k5D7yWMUoVh4fOVB9dw1Ty6eBDdB/jeZQ+PPBnNIeHDJg/A4BL92tBf04dm9Onq4eczC49c9DjCa53D04MzzI5nntQeTx1cexmHhSdubHsNu8sRYduoxd1t7MITndjd5GPmH2QOYG48ehEeXHl14DsXjloiH4ukemwfNY9DZAzPTUpHqsaVnSNxnoaSeOeJjvPT0xWNLT36qHh095XkNk4dJjsBMQUduHr/msdnzGB7mYeH5YeFRjB6HhcfC05O5ifrSw8i9Ljw8enJj2KkHk2fOnz+b53A/e36ZPRnFcw+SMSH1gkfBZb4LcgqP8EvB/ujBZzxYemT05PBkPvbG0aP5lRQPhuphKZ4vc/XY6DFw8/jCg8mT00UPrniQV55N8zxvhb8gw3bp6U48Xj2+9GRswsPNw8Bh9gyN0Qa1uPPSA1z09EfPo/AN+egZiietPIAUz1P1ZMwehAcCDN1AcuaRhUcNWHu4q567h4gPnlmYyPH6Y3j2PdxeFY/OHm0eyMJze+7Ju+3oOZBe8xjhkifT++LB5Hkhpu602cFt+2KgvnoyqYcHlzwGwO235knV41c9DD3xqDuPnpt3zTMIb2fPvtOj5+eB7hcehEcnD4rnsCN4eLh5+M3Kg7/xWPNg8vxx9DyS5zE+xfP6w0BdeDKTX/EMqXp09ODo4aoYrnmw9txXD33FIC6exEyWO/HJ8+bt2qMrDxPcqqdHtL0k1s95PoVHTz198/xPQCz4/ZCkeXz0vHz7if5zydMSEgCDZfTk0fOmeSQvPK1QVtsK6kbIZk+WM89mJ5mMd6MHxbOlnz5G9g+zB3/reT15GsNOPRuGY/Ro9eCKJ4Wnzi96m5Yeg517ZPJY87gjb2fPetuD4pEzDwQYPQjPvnm4evZp9Ejx/DZ6ZOUZmMQNrj56kJoHuOjBXRo9duLx6lHKOPfE+vzhLdNPOnl89DjQ8plTnV8W45NUD1P+nMc2SVyj5YLn/1ASYH8b+SzNw6OnCw8zuauGx7wtsLNHDf/c47YRXPd81TxblmHhARwfvl96TKMfmfvoEU44JMrhMZAwoJB81RMM24dHTz3SPO+q55Bk6cnFQ++EduGRXPeHQHiiWjxpV9Znnj0MZEH12AUPSE88uc332fO+eNQGBn4tno/NY270AHqqM6XuD9tOODxGCqSE4X72gBlaPKgeu+Bxt9+XHg0PIE5uyHcPNT6PjLwpHjQPLL/sQBIKAVUEEB7U+HDaYehoACQ8zFtBCSbO4qMnnj9mDwuap1cyZL7rABJY5qNt9gBmeBEeg+XwYI4PEJ6cUvEcAIGbEPPt0mPNY2eeZ8C9eMwYzZPj/cV82zyQ8ACwEw8UwJnHJg+HZy+T5656tHqseVTJbfbkyYPJw1/W8852Fx4vnpuFR82x68885sWjkwfMxbOpHqZUPPOyPHqAk/j45MHs+dQVz2HHqXoMyF+QKYDqcUeq5/fxfKqTRyDT+rxdeF7zXb/0+Oq8HELo7GnU/Oboydh3LJNn+OXq95a1R714wNP3DQcT8SYtPHXQtce8emzyWKaH6oEAfwHoySkS2Hjk2AAAAABJRU5ErkJggg=='},
            short_grass: {bin: 'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQBAMAAADt3eJSAAAAFVBMVEUAAAC4t7igoKCRkZGDgYN2d3ZsbGyS5OzOAAAAAXRSTlMAQObYZgAAAG5JREFUeNptyDESgyAQheHHSvpt7DcDpCaGHMABqRnwBI73P4Ng7Wv+bx6eJgSmAVJguau0cC/eND6AK61dHeS/emCeXJwJEKNe4rhAFirWS4UlU4IsE3xsbTcx4Jda3Fzy0PWs+W8TwnEeOX+2CxhUDj0662krAAAAAElFTkSuQmCC'},
            dandelion: {bin: 'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAUklEQVQ4y2NgGAXDHfx/4/8fhMnW/O+a5f+Pc1VJNwSkAaZxb5YS2CCyDCFbMwyI17D8B2GyNHr1a/wPXa0Lpsm2HWYACJPlEpABZHsDBIixGQCyM01OrS9sngAAAABJRU5ErkJggg=='},
            oxeye_daisy: {bin: 'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAATlBMVEXr6+tR2/1vtE0nrPtXpDJVnzFRoStQmShVkzJRkTFBixxDhiPBQCM5fhYyeg4AAAD39/fW6Oj/7E/+1jn1uiebvb3xnSVVqy1Smi4XfASspZShAAAAEHRSTlMAAAAAAAAAAAAAAAAAAAAAHik/2wAAAGZJREFUeNptyFEOAiAMBNGqiCJWdgWE3v+ixsSkjXG+Jk/aT/IX5D7BkzgcSIDNgRi9czoA/TkAh8nRX6BDIkBmB6nETOJQz7dtSR308lhaItheSQO0YqvYNYDWZbkFyLojfLLjd97lCA7ioBDbWwAAAABJRU5ErkJggg=='},
        }

        const directions = [
            { x: 0, y: 1, z: 0 },   // Верх
            { x: 0, y: -1, z: 0 },  // Низ
            { x: 0, y: 0, z: 1 },   // Перед
            { x: 0, y: 0, z: -1 },  // Зад
            { x: -1, y: 0, z: 0 },  // Лево
            { x: 1, y: 0, z: 0 }    // Право
        ]

        const blocks_palette = {
            dirt: [
                {color: [0.4039, 0.2667, 0.1294], flag: 32, texture: textures.dirt}, // Верх — зеленый
                {color: [0.4039, 0.2667, 0.1294], flag: 32, texture: textures.dirt}, // Низ — коричневый
                {color: [0.4039, 0.2667, 0.1294], flag: 32, texture: textures.dirt}, // Перед — коричневый
                {color: [0.4039, 0.2667, 0.1294], flag: 32, texture: textures.dirt}, // Зад — коричневый
                {color: [0.4039, 0.2667, 0.1294], flag: 32, texture: textures.dirt}, // Лево — коричневый
                {color: [0.4039, 0.2667, 0.1294], flag: 32, texture: textures.dirt}, // Право — коричневый
            ],
            grass_block: [
                {color: [99/256, 127/256, 64/256], texture: textures.grass_block_top}, // Верх — зеленый
                {color: [0.4039, 0.2667, 0.1294], texture: textures.dirt}, // Низ — коричневый
                {color: [0.4039, 0.2667, 0.1294], flag: 2 | 32, texture: textures.dirt}, // Перед — коричневый
                {color: [0.4039, 0.2667, 0.1294], flag: 2 | 32, texture: textures.dirt}, // Зад — коричневый
                {color: [0.4039, 0.2667, 0.1294], flag: 2 | 32, texture: textures.dirt}, // Лево — коричневый
                {color: [0.4039, 0.2667, 0.1294], flag: 2 | 32, texture: textures.dirt}, // Право — коричневый
            ],
            stone: [
                {color: [0.5451, 0.5333, 0.5294], texture: textures.stone}, // Верх — светло-серый
                {color: [0.5451, 0.5333, 0.5294], texture: textures.stone}, // Низ — темно-серый
                {color: [0.5451, 0.5333, 0.5294], texture: textures.stone}, // Перед — темно-серый (с оттенком)
                {color: [0.5451, 0.5333, 0.5294], texture: textures.stone}, // Зад — темно-серый (с оттенком)
                {color: [0.5451, 0.5333, 0.5294], texture: textures.stone}, // Лево — темно-серый
                {color: [0.5451, 0.5333, 0.5294], texture: textures.stone}, // Право — темно-серый
            ],
            water: [
                {color: [63/256, 118/256, 228/256], flag: 1, texture: textures.water_still}, // Верх — синий
                {color: [63/256, 118/256, 228/256], texture: textures.water_still}, // Низ — синий
                {color: [63/256, 118/256, 228/256], texture: textures.water_still}, // Перед — синий
                {color: [63/256, 118/256, 228/256], texture: textures.water_still}, // Зад — синий
                {color: [63/256, 118/256, 228/256], texture: textures.water_still}, // Лево — синий
                {color: [63/256, 118/256, 228/256], texture: textures.water_still}, // Право — синий
            ],
            sand: [
                {color: [0.8, 0.8, 0.6], texture: textures.sand}, // Верх — светло-коричневый
                {color: [0.8, 0.8, 0.6], texture: textures.sand}, // Низ — светло-коричневый
                {color: [0.8, 0.8, 0.6], texture: textures.sand}, // Перед — светло-коричневый
                {color: [0.8, 0.8, 0.6], texture: textures.sand}, // Зад — светло-коричневый
                {color: [0.8, 0.8, 0.6], texture: textures.sand}, // Лево — светло-коричневый
                {color: [0.8, 0.8, 0.6], texture: textures.sand}, // Право — светло-коричневый
            ],
            oak_log: [
                {color: [0.7, 0.7, 0.5], texture: textures.oak_log_top}, // Верх — коричневый
                {color: [0.7, 0.7, 0.5], texture: textures.oak_log_top}, // Низ — коричневый
                {color: [146/256, 108/256, 77/256], flag: 8, texture: textures.oak_log}, // Перед — коричневый
                {color: [146/256, 108/256, 77/256], flag: 8, texture: textures.oak_log}, // Зад — коричневый
                {color: [146/256, 108/256, 77/256], flag: 8, texture: textures.oak_log}, // Лево — коричневый
                {color: [146/256, 108/256, 77/256], flag: 8, texture: textures.oak_log}, // Право — коричневый
            ],
            oak_leaves: [
                {color: [0.0, 0.6, 0.0], flag: 16, texture: textures.oak_leaves}, // Верх — зеленый
                {color: [0.0, 0.6, 0.0], flag: 16, texture: textures.oak_leaves}, // Низ — зеленый
                {color: [0.0, 0.6, 0.0], flag: 16, texture: textures.oak_leaves}, // Перед — зеленый
                {color: [0.0, 0.6, 0.0], flag: 16, texture: textures.oak_leaves}, // Зад — зеленый
                {color: [0.0, 0.6, 0.0], flag: 16, texture: textures.oak_leaves}, // Лево — зеленый
                {color: [0.0, 0.6, 0.0], flag: 16, texture: textures.oak_leaves}, // Право — зеленый
            ],
            bedrock: [
                {color: [0.1, 0.1, 0.1], texture: textures.bedrock}, // Верх — черный
                {color: [0.1, 0.1, 0.1], texture: textures.bedrock}, // Низ — черный
                {color: [0.1, 0.1, 0.1], texture: textures.bedrock}, // Перед — черный
                {color: [0.1, 0.1, 0.1], texture: textures.bedrock}, // Зад — черный
                {color: [0.1, 0.1, 0.1], texture: textures.bedrock}, // Лево — черный
                {color: [0.1, 0.1, 0.1], texture: textures.bedrock}, // Право — черный
            ],
            gravel: [
                {color: [0.5, 0.5, 0.5], flag: 4, texture: textures.gravel}, // Верх — серый
                {color: [0.5, 0.5, 0.5], flag: 4, texture: textures.gravel}, // Низ — серый
                {color: [0.5, 0.5, 0.5], flag: 4, texture: textures.gravel}, // Перед — серый
                {color: [0.5, 0.5, 0.5], flag: 4, texture: textures.gravel}, // Зад — серый
                {color: [0.5, 0.5, 0.5], flag: 4, texture: textures.gravel}, // Лево — серый
                {color: [0.5, 0.5, 0.5], flag: 4, texture: textures.gravel}, // Право — серый
            ],
            short_grass: [
                {color: [1, 1, 1], flag: 128 | 64, texture: textures.short_grass},
            ],
            dandelion: [
                {color: [1, 1, 1], flag: 128, texture: textures.dandelion},
            ],
            oxeye_daisy: [
                {color: [1, 1, 1], flag: 128, texture: textures.oxeye_daisy},
            ],
        }

        const face_offsets = [
            { vertices: [-1, 1, -1, -1, 1, 1, 1, 1, 1, -1, 1, -1, 1, 1, 1, 1, 1, -1], uv: [0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0] }, // Верх
            { vertices: [-1, -1, 1, -1, -1, -1, 1, -1, -1, -1, -1, 1, 1, -1, -1, 1, -1, 1], uv: [0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1] }, // Низ
            { vertices: [-1, -1, 1, 1, -1, 1, 1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1], uv: [0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1] }, // Перед
            { vertices: [-1, -1, -1, -1, 1, -1, 1, 1, -1, -1, -1, -1, 1, 1, -1, 1, -1, -1], uv: [0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0] }, // Зад
            { vertices: [-1, -1, -1, -1, -1, 1, -1, 1, 1, -1, -1, -1, -1, 1, 1, -1, 1, -1], uv: [1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1] }, // Лево
            { vertices: [1, -1, -1, 1, 1, -1, 1, 1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1], uv: [0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0] }, // Право
        ]

        const grass_scale = 0.8

        const grass_planes = [
            // Первая плоскость (диагональная, XZ)
            [
                -1 * grass_scale, -1, -1 * grass_scale,
                1 * grass_scale, -1,  1 * grass_scale,
                1 * grass_scale, -1 + grass_scale * 2,  1 * grass_scale,
                -1 * grass_scale, -1, -1 * grass_scale,
                1 * grass_scale, -1 + grass_scale * 2,  1 * grass_scale,
                -1 * grass_scale, -1 + grass_scale * 2, -1 * grass_scale,
            ],
            // Вторая плоскость (диагональная, XZ)
            [
                -1 * grass_scale, -1,  1 * grass_scale,
                1 * grass_scale, -1, -1 * grass_scale,
                1 * grass_scale, -1 + grass_scale * 2, -1 * grass_scale,
                -1 * grass_scale, -1,  1 * grass_scale,
                1 * grass_scale, -1 + grass_scale * 2, -1 * grass_scale,
                -1 * grass_scale, -1 + grass_scale * 2,  1 * grass_scale,
            ],
        ]

        const grasses = [blocks_palette.short_grass]
        const plants = [
            blocks_palette.dandelion,
            blocks_palette.oxeye_daisy,
            // poppy, blue_orchid, allium, azure_bluet, red_tulip, orange_tulip, white_tulip, pink_tulip, cornflower, lily_of_the_valley, sweet_berry_bush
        ]

        const ao_indexes = [0, 1, 2, 0, 2, 3]
        const ao_table = [
            {fix: 1, moves: [ [-1, 1, -1], [-1, 1, 1], [1, 1, 1], [1, 1, -1]] },
            null, // {fix: 1, moves: [ [1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1]] },
            {fix: 2, moves: [ [-1, -1, 1], [1, -1, 1], [1, 1, 1], [-1, 1, 1]] },
            {fix: 2, moves: [ [-1, -1, -1], [-1, 1, -1], [1, 1, -1], [1, -1, -1]] },
            {fix: 0, moves: [ [-1, -1, -1], [-1, -1, 1], [-1, 1, 1], [-1, 1, -1]] },
            {fix: 0, moves: [ [1, -1, -1], [1, 1, -1], [1, 1, 1], [1, -1, 1]] },
        ]

        let bob_зarams = {
            time: 0,              // Время для bobview
            frequency: 8,         // Частота покачивания
            amplitudeX: 0.05,     // Горизонтальная амплитуда
            amplitudeY: 0.1,      // Вертикальная амплитуда
            amplitude: 0.1,       // Вертикальная амплитуда
        }

        const chunks = {
            list: new Map(),
            has(x, z) {
                const xx = this.list.get(x)
                if(!xx) return false
                return xx.has(z)
            },
            add(x, z, chunk) {
                if(!this.list.has(x)) {
                    this.list.set(x, new Map())
                }
                this.list.get(x).set(z, chunk)
            },
        }

        const player_height     = 1.8
        const fog_color         = 0x87CEEB // Цвет ясного неба в Minecraft
        const pnw               = performance.now()
        const world_size        = {x: 16, y: 4, z: 16}
        const chunk_size        = {x: 24, y: 40, z: 24}
        const DEFAULT_SPAWN_POS = {x: (world_size.x * chunk_size.x) / 2, y: 120, z: (world_size.z * chunk_size.z) / 2}
        const scene_info        = { quads: 0 }
        const saved_pos         = localStorage.getItem('player_position')
        const init_pos          = saved_pos ? JSON.parse(saved_pos) : DEFAULT_SPAWN_POS
        const simplex           = new SimplexNoise('1')
        const world             = new World(chunk_size, world_size)
        const world_water       = new World(chunk_size, world_size)
        const world_leaves      = new World(chunk_size, world_size)
        const player_controller = new PlayerController(world, 9.8, 0.9, init_pos)
        const velocity          = new THREE.Vector3()
        const direction         = new THREE.Vector3()
        const up                = new THREE.Vector3(0, 1, 0)
        const neighbours_cache  = [0, 0, 0, 0, 0, 0]
        const water_level       = 64
        const tree_chance       = 64
    
        let stats
        let beft = 1
        let spectator_mode = localStorage.getItem('spectator_mode') === 'true'
        let move_forward = false, move_backward = false, move_left = false, move_right = false
        let move_up = false, move_down = false
        let speed_mul = 1
        let pnw1
        let shader_material
        let doubleside_shader_material
        let manager
        let manager_doubleside
        let manager_transparent

        // 
        const scene = new THREE.Scene()
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000)
        const renderer = new THREE.WebGLRenderer({ antialias: false, precision: 'highp' })
        renderer.setPixelRatio(window.devicePixelRatio) // Настраиваем разрешение канваса
        renderer.setSize(window.innerWidth, window.innerHeight) // Устанавливаем размер
        scene.background = new THREE.Color(fog_color) // Устанавливаем фон
        camera.position.set(init_pos.x, init_pos.y, init_pos.z)
        const controls = new THREE.PointerLockControls(camera, document.body)

        // Создаем элемент для отображения координат
        const coords_el = document.createElement('div')
        coords_el.classList.add('coords')
        document.body.appendChild(coords_el)

        function addListeners() {

            document.body.addEventListener('click', () => controls.lock())

            // on mouse wheel
            document.addEventListener('wheel', (event) => {
                speed_mul *= event.deltaY < 0 ? 1.1 : 0.9
            })

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight
                camera.updateProjectionMatrix()
                renderer.setSize(window.innerWidth, window.innerHeight)
            })

            const handleKeyEvent = (event, is_key_down) => {
                const key_state = is_key_down;
                switch (event.code) {
                    case 'KeyW': move_forward = key_state; break
                    case 'KeyS': move_backward = key_state; break
                    case 'KeyA': move_left = key_state; break
                    case 'KeyD': move_right = key_state; break
                    case 'ShiftLeft': move_down = key_state; break
                    case 'Space': 
                        if (key_state) player_controller.jump()
                        move_up = key_state
                        break
                    case 'F4': 
                        if (!key_state) {
                            const pos = {...(spectator_mode ? controls.getObject().position : player_controller.position)}
                            localStorage.setItem('player_position', JSON.stringify(pos))
                            localStorage.setItem('spectator_mode', spectator_mode)
                        }
                        break;
                    case 'KeyR': 
                        if (!key_state) {
                            let pos = localStorage.getItem('player_position')
                            teleportTo(pos ? JSON.parse(pos) : DEFAULT_SPAWN_POS)
                            break
                        }
                    case 'F8': 
                        if (key_state) teleportRandomly()
                        break;
                    case 'KeyG': 
                        if (!key_state) {
                            spectator_mode = !spectator_mode
                            teleportTo({...(spectator_mode ? player_controller.position : controls.getObject().position)})
                            event.preventDefault()
                            event.stopPropagation()
                        }
                        break
                }
            };

            document.addEventListener('keydown', (event) => handleKeyEvent(event, true))
            document.addEventListener('keyup', (event) => handleKeyEvent(event, false))

        }

        function createShaderMaterial(texture, options = {}) {
            texture.minFilter = THREE.NearestFilter // Для уменьшения
            texture.magFilter = THREE.NearestFilter // Для увеличения
            texture.needsUpdate = true // Обновляем текстуру
            return new THREE.ShaderMaterial({
                vertexColors: true,
                side: THREE.FrontSide,
                transparent: true, // Включить прозрачность
                ...options,
                uniforms: THREE.UniformsUtils.merge([
                    THREE.UniformsLib.lights, // Подключаем освещение и шедоумапы
                    {
                        cameraPosition: { value: new THREE.Vector3() }, // Передаем позицию камеры
                        cameraOffset: { value: new THREE.Vector3() }, // Передаем позицию камеры
                        fogColor: { value: new THREE.Color(0x87CEEB) }, // Цвет тумана
                        fogNear: { value: 100.0 }, // Начало тумана
                        time: { value: 0.0 }, // текущее время
                        fogFar: { value: world_size.x * chunk_size.x * 2 }, // Конец тумана
                        texture: { value: texture }, // передача текстуры
                    }
                ]),
                vertexShader: `
                    precision highp float;

                    varying vec3 vColor;
                    varying vec3 vWorldPosition;
                    varying vec4 vShadowCoord;
                    varying vec2 vUv; // Передаём UV во фрагментный шейдер
                    attribute float flag;
                    varying float vFlag;
                    uniform float time;
                    varying float vTime;
                    uniform vec3 cameraOffset; // Смещение камеры

                    varying vec3 vNormal;

                    #include <common>
                    #include <shadowmap_pars_vertex> // Подключаем расчеты для шедоумап

                    bool checkFlag(int bit) {
                        float rounded = floor(vFlag + 0.5); // Округляем значение
                        float divisor = float(bit);
                        return mod(floor(rounded / divisor), 2.0) >= 1.0; // Проверяем, установлен ли бит
                    }

                    void main() {
                        vUv = uv;
                        vTime = time;
                        vFlag = flag; // Передаем во фрагментный шейдер
                        vColor = color;
                        vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                        vWorldPosition = worldPosition.xyz;
                        vNormal = normal; // Передаём нормаль во фрагментный шейдер

                        // Вычисляем координаты для шедоумапы
                        #include <worldpos_vertex>
                        #include <shadowmap_vertex>

                        // waves
                        vec3 modifiedPosition = position;
                        if (checkFlag(1)) {
                            // волны воды
                            modifiedPosition.y -= 2./16.;
                            modifiedPosition.y += sin(position.x * 2.0 + time * 2.) * 0.0625;
                            modifiedPosition.y += cos(position.z * 2.0 + time * 2.) * 0.0625;
                        } else if (checkFlag(16)) {
                            // листва
                            modifiedPosition.x += sin(position.x * 2.0 + time * 2.) * 0.0625;
                            modifiedPosition.x += cos(position.z * 2.0 + time * 2.) * 0.0625;
                            modifiedPosition.z += sin(position.x * 2.0 + time * 2.) * 0.0625;
                            modifiedPosition.z += cos(position.z * 2.0 + time * 2.) * 0.0625;
                        }

                        gl_Position = projectionMatrix * modelViewMatrix * vec4(modifiedPosition - cameraOffset, 1.0);
                    }
                `,
                fragmentShader: `
                    precision highp float;
                    #extension GL_OES_standard_derivatives : enable
                    uniform sampler2D map; // Добавьте текстуру
                    varying vec2 vUv; // Принимаем UV из вершины
                    varying float vTime;

                    varying vec3 vColor;
                    varying vec3 vWorldPosition;
                    varying vec4 vShadowCoord;
                    varying float vFlag;
                    varying vec3 vNormal; // Получаем нормаль из вершинного шейдера

                    uniform vec3 fogColor;       // Цвет тумана
                    uniform float fogNear;       // Начало тумана
                    uniform float fogFar;        // Конец тумана

                    uniform sampler2D texture; // Передаём текстуру в шейдер

                    const int FLAG_WATER_ANIMATED = 1;
                    const int FLAG_GRASS_BLOCK_SIDE = 2;
                    // const int UNUSED_FLAG_GRAVEL = 4;
                    // const int FLAG_ = 8;
                    const int FLAS_ANIMATED_LEAVES = 16;
                    const int FLAG_NO_CAN_TAKE_AO = 128;
                    const int FLAG_GRASS_COLOR = 64;

                    float hash(vec3 p) {
                        p = fract(p * 0.1031);
                        p += dot(p, p.yzx + 19.19);
                        return fract((p.x + p.y) * p.z);
                    }

                    bool checkFlag(int bit) {
                        float rounded = floor(vFlag + 0.5); // Округляем значение
                        float divisor = float(bit);
                        return mod(floor(rounded / divisor), 2.0) >= 1.0; // Проверяем, установлен ли бит
                    }

                    void main() {

                        vec3 grass_color = vec3(84./256., 147./256., 42./256.);
                        vec3 water_color = vec3(15./256., 94./256., 156./256.);

                        // Расчет тени
                        float shadow = 1.0;
                        #if NUM_DIR_LIGHTS > 0
                            shadow = texture2DShadow(shadowMap[0], vShadowCoord.xyz);
                        #endif

                        float scale = 16.0;
                        vec3 pp = vWorldPosition;
                        if(checkFlag(8)) {
                            pp.y /= 2.0;
                        }
                        vec3 quantizedPos = floor(pp * scale + 1e-3); // Добавлен эпсилон
                        float randomness = hash(quantizedPos);
                        vec3 finalColor = vColor;

                        vec2 uv = vUv;

                        if (checkFlag(FLAG_WATER_ANIMATED)) {
                            float frame_count = 32.0;
                            float frame_height = 1.0 / frame_count;
                            float current_frame = mod(floor(vTime * 16.), frame_count);
                            uv.y = uv.y - frame_height * current_frame;
                        }

                        vec4 texColor = texture2D(texture, uv);

                        if(texColor.a < 0.1) {
                            discard;
                        }

                        if(checkFlag(FLAS_ANIMATED_LEAVES)) {
                            texColor.rgb *= grass_color;
                        }
                        if(checkFlag(FLAG_WATER_ANIMATED)) {
                            texColor.rgb *= water_color;
                        }
                        if(checkFlag(FLAG_GRASS_COLOR)) {
                            texColor.rgb *= grass_color;
                        }

                        finalColor = texColor.rgb;

                        if (checkFlag(FLAG_GRASS_BLOCK_SIDE)) {
                            // шапка травы
                            float quadY = mod(vWorldPosition.y, 1.0);
                            float rr = vec3(randomness).y * 0.2;
                            if (quadY > floor((0.7 + rr) * 16.) / 16.) {
                                // Изменяем цвет для верхней части квада
                                finalColor = grass_color; // Красный цвет, например
                                vec3 colorDeviation = vec3(randomness) * 0.2 - 0.1;
                                finalColor = clamp(finalColor + colorDeviation, 0.0, 1.0) * shadow;
                            }
                        }

                        finalColor *= vColor;

                        if(checkFlag(FLAG_NO_CAN_TAKE_AO)) {
                            finalColor *= 1.2; // Осветлить верх
                        } else {
                            // Вычисляем нормаль на основе позиции
                            vec3 normal = normalize(vNormal); // Нормализуем перед использованием
                            // Применяем изменение цвета в зависимости от нормали
                            if (normal.y > 0.5) {
                                finalColor *= 1.2; // Осветлить верх
                            } else if (normal.y < -0.5) {
                                finalColor *= 0.5; // Затемнить низ
                            } else if (normal.z < 0.0) {
                                finalColor *= 0.7; // Затемнить север
                            } else if (normal.z > 0.0) {
                                finalColor *= 0.7; // Осветлить юг
                            } else {
                                finalColor *= 0.9; // Остальные случаи
                            }
                        }

                        // Рассчитываем расстояние до камеры
                        float distanceToCamera = length(vWorldPosition - cameraPosition);

                        // Применяем туман
                        float fogFactor = smoothstep(fogNear, fogFar, distanceToCamera);
                        vec3 foggedColor = mix(finalColor, fogColor, fogFactor);

                        float alpha = checkFlag(1) ? 0.75 : 1.0;
                        gl_FragColor = vec4(foggedColor, alpha);
                    }
                `
            })

        }

        async function createTexture() {
            const canvas = document.createElement('canvas')
            const ctx = canvas.getContext('2d')
            const keys = Object.keys(textures)
            // Загружаем все текстуры и определяем их размеры
            const images = await Promise.all(keys.map(key => {
                const img = new Image()
                img.src = 'data:image/png;base64,' + textures[key].bin
                return new Promise(resolve => {
                    img.onload = () => resolve({ key, img, width: img.width, height: img.height })
                })
            }))
            // Определяем сторону атласа как ближайшую степень двойки от самой длинной стороны текстур
            const max_side = Math.max(...images.map(img => Math.max(img.width, img.height)))
            const atlas_size = Math.pow(2, Math.ceil(Math.log2(max_side)))
            canvas.width = atlas_size
            canvas.height = atlas_size
            // Размещаем текстуры в атласе
            let x_offset = 0
            let y_offset = 0
            let row_height = 0
            images.forEach(img => {
                if (x_offset + img.width > atlas_size) {
                    x_offset = 0
                    y_offset += row_height
                    row_height = 0
                }
                if (y_offset + img.height > atlas_size) {
                    throw new Error('Не удалось разместить все текстуры в атласе. Увеличьте размер атласа.')
                }
                ctx.drawImage(img.img, x_offset, y_offset, img.width, img.height)
                // Сохраняем UV-координаты
                textures[img.key].uv = [
                    x_offset / atlas_size,
                    1 - y_offset / atlas_size,
                    (x_offset + img.width) / atlas_size,
                    1 - (y_offset + img.width) / atlas_size
                ]
                x_offset += img.width
                row_height = Math.max(row_height, img.height)
            })
            // function downloadCanvas(canvas, filename = 'atlas.png') {
            //     const link = document.createElement('a')
            //     link.download = filename
            //     link.href = canvas.toDataURL('image/png')
            //     link.click()
            // }
            // downloadCanvas(canvas, 'texture-atlas.png')
            return new THREE.CanvasTexture(canvas)
        }

        // Функция для обновления координат
        function updateCoordinates(x, y, z) {
            coords_el.innerHTML = `<div class="f3-line">${x.toFixed(1)}, ${y.toFixed(1)}, ${z.toFixed(1)}</div>
            <div class="f3-line"><strong class="key">G</strong> gamemode: ${player_controller.gamemode ? 'creative' : 'survival'}</div>
            <div class="f3-line"><strong class="key">F8</strong> random teleport</div>
            <div class="f3-line"><strong class="key">F4</strong> set home</div>
            <div class="f3-line"><strong class="key">F6</strong> return to home</div>`
        }

        function pseudoRandom(seed) {
            let value = seed
            return function() {
                value = (value * 16807) % 2147483647
                return value / 2147483647
            }
        }

        function setBlock(layer, x, y, z, block, is_water = false, is_leaves = false) {
            if(x < 0 || x >= world_size.x * chunk_size.x) return
            if(y < 0 || y >= world_size.y * chunk_size.y) return
            if(z < 0 || z >= world_size.z * chunk_size.z) return
            x = Math.floor(x)
            y = Math.floor(y)
            z = Math.floor(z)
            const wrld = is_water ? world_water : is_leaves ? world_leaves : world
            if(layer == 0) {
                wrld.setBlockAt(x, y, z, 1)
            } else {
                const mgr = is_water ? manager_transparent : manager
                if(is_leaves || wrld.checkNeighbors(x, y, z, neighbours_cache)) {
                    mgr.addCube(x, y, z, block, neighbours_cache, is_leaves)
                }
            }
        }

        // Генератор
        function generateChunk(_cx, _cz) {

            const pn = performance.now()

            let iter = 0
            let chunks_count = 0
            let n0 = 0
            let n2 = 0
            let ocean = 0
            let planing = 0

            function getXZNoise(x, z) {
                const x2 = x + 1024
                const z2 = z + 1024
                n0 = simplex.noise2D(x / 2, z / 2)
                const n1 = simplex.noise2D(x / 64, z / 64)
                n2 = simplex.noise2D(x2 / 16, z2 / 16)
                const n3 = simplex.noise2D(x2 / 8, z2 / 8)
                return (n1 * 0.7 + n2 * 0.25 + n3 * 0.05)
            }

            function calcH(x, z) {
                ocean = simplex.noise2D((x - 8192) / 384, (z - 8192) / 384)
                planing = (simplex.noise2D((x - 1024) / 256, (z - 1024) / 256))
                const height = getXZNoise(x, z) * (32 * ((planing + 1) / 2))
                return Math.ceil (
                    (64 + ocean * 16) + (height < 0 ? height : height * 2)
                )
            }

            function drawTree(layer, x, y, z, random) {
                const height = Math.ceil(random() * 8 + 2)
                for(let yy = 0; yy < height; yy++) {
                    setBlock(layer, x, y + yy, z, blocks_palette.oak_log)
                }
                // draw leaves
                const radius = {xz: 3, y: 7}
                const ax = x
                const ay = y + height - 2
                const az = z
                for(let i = 0 ; i < 6; i++) neighbours_cache[i] = 0
                for(let xx = -radius.xz; xx <= radius.xz; xx++) {
                    for(let yy = 0; yy <= radius.y; yy++) {
                        for(let zz = -radius.xz; zz <= radius.xz; zz++) {
                            if(xx * xx + yy * yy + zz * zz <= radius.xz * radius.xz) {
                                if(xx == 0 && yy < 2 && zz == 0) continue
                                setBlock(layer, ax + xx, ay + yy, az + zz, blocks_palette.oak_leaves, false, true)
                            }
                        }
                    }
                }
            }

            for(let layer = 0; layer < 2; layer++) {
                for(let cx = 0; cx < world_size.x; cx++) {
                    for(let cz = 0; cz < world_size.z; cz++) {

                        const random = pseudoRandom(cx * 256 + cz)
                        if (layer == 0) chunks_count++
                        const has_tree = Math.round(simplex.noise2D(cx, cz) * 100)

                        for(let bx = 0; bx < chunk_size.x; bx++) {
                            for(let bz = 0; bz < chunk_size.z; bz++) {

                                const x = cx * chunk_size.x + bx
                                const z = cz * chunk_size.z + bz
                                const h = calcH(x, z)

                                for(let y = 0; y < 128; y++) {
                                    const ax = x
                                    const ay = y
                                    const az = z
                                    iter++
                                    if(y < h) {
                                        let block = blocks_palette.stone
                                        const y_from_top = h - y
                                        if(y < 80 + n2 * (8 * planing)) {
                                            if(y == water_level - 1 && y == h - 1) {
                                                block = blocks_palette.sand
                                            } else if(y < n0 * 2 + 3) {
                                                block = blocks_palette.bedrock
                                            } else {
                                                if(y_from_top == 1 && y > water_level - 1) {
                                                    block = blocks_palette.grass_block
                                                    let gr = random()
                                                    if(layer == 1) {
                                                        if(gr < .1) {
                                                            gr /= .1
                                                            const block = gr < .9 ? grasses[Math.floor((gr/.9) * grasses.length)] : plants[Math.floor(((gr-.9)/.1) * plants.length)]
                                                            manager_doubleside.addPlant(x, y + 1, z, 1, block)
                                                        }
                                                    }
                                                } else if(y_from_top < 3) {
                                                    block = y < water_level ? blocks_palette.gravel : blocks_palette.dirt
                                                }
                                            }
                                        }
                                        setBlock(layer, ax, ay, az, block)
                                    } else if(y < water_level && y >= h) {
                                        setBlock(layer, ax, ay, az, blocks_palette.water, true)
                                    }
                                }

                                if(h > water_level && h < 75 && Math.round(random() * tree_chance) == 0) {
                                    drawTree(layer, x, h, z, random)
                                }

                            }
                        }

                    }
                }
            }

            console.log('Iter:', iter.toLocaleString(), 'Chunks:', chunks_count.toLocaleString(), 'ChunksTime:', ((performance.now() - pn)/chunks_count).toLocaleString())

        }

        function applyBobView(position, is_moving, elapsed_time) {
            if(!player_controller.isGrounded) {
                elapsed_time = 0
            }
            const { frequency, amplitudeX, amplitudeY } = bob_зarams
            // Если игрок движется, увеличиваем время
            if (is_moving) {
                beft = 1
            } else {
                beft *= 0.9
            }
            bob_зarams.time += elapsed_time * 0.001 * beft
            // Смещение по Y (резкое вертикальное качание)
            const offset_y = Math.abs(Math.sin(bob_зarams.time * frequency)) * amplitudeY
            // Смещение по X (плавное горизонтальное качание)
            const offset_x = Math.sin(bob_зarams.time * frequency * 0.5) * amplitudeX
            // Возвращаем позицию с учетом эффекта
            return {
                x: position.x + offset_x,
                y: position.y - offset_y,
                z: position.z
            }
        }

        function teleportTo(pos) {
            if (spectator_mode) {
                controls.getObject().position.set(pos.x, pos.y, pos.z)
            } else {
                player_controller.position.set(pos.x, pos.y, pos.z)
                player_controller.velocity.y = 0
            }
        }

        function teleportRandomly() {
            const range = init_pos.x * 0.8 // диапазон координат для телепортации
            teleportTo({
                x: Math.round(init_pos.x + Math.random() * range - range / 2) + 0.5,
                y: Math.round(init_pos.y + Math.random() * 16), // чтобы не улетать слишком высоко
                z: Math.round(init_pos.z + Math.random() * range - range / 2) + 0.5,
            })
        }

        // Функция анимации
        function animate() {

            stats.begin() // Начало замера

            requestAnimationFrame(animate)

            const elapsed = performance.now() - pnw1

            if(spectator_mode) {

                const speed = 0.025 * speed_mul
                velocity.x *= 0.95
                velocity.y *= 0.95
                velocity.z *= 0.95

                if (move_forward) velocity.z += speed
                if (move_backward) velocity.z -= speed
                if (move_left) velocity.x += speed
                if (move_right) velocity.x -= speed
                if (move_up) velocity.y += speed
                if (move_down) velocity.y -= speed

                // Рассчитываем направление движения относительно камеры
                direction.set(0, 0, 0)
                camera.getWorldDirection(direction)
                direction.y = 0 // Движение только по горизонтали
                direction.normalize()

                const right = new THREE.Vector3().crossVectors(up, direction).normalize()
                const move = new THREE.Vector3()
                move.addScaledVector(direction, velocity.z)
                move.addScaledVector(right, velocity.x)
                move.y += velocity.y

                controls.getObject().position.add(move)

                // Обновляем панель с координатами
                const camera_position = camera.position // Используйте ваши координаты
                updateCoordinates(camera_position.x, camera_position.y, camera_position.z)

            } else {

                player_controller.update(elapsed)

                // Обновление позиции камеры
                const player_pos = player_controller.position
                const is_moving = move_forward || move_backward || move_left || move_right
                const camera_pos = applyBobView(player_pos, is_moving, elapsed)
                controls.getObject().position.set(camera_pos.x, camera_pos.y, camera_pos.z)

                // Обновляем панель с координатами
                updateCoordinates(player_pos.x, player_pos.y, player_pos.z)

            }

            for(const mat of [doubleside_shader_material, shader_material]) {
                mat.uniforms.cameraPosition.value.copy({x: camera.position.x, y: camera.position.y, z: camera.position.z})
                mat.uniforms.time.value = performance.now() / 1000
                mat.uniforms.cameraOffset.value.y = player_height
            }

            renderer.render(scene, camera)
            stats.end() // Конец замера
            pnw1 = performance.now()

        }

        createTexture().then(texture => {

            shader_material = createShaderMaterial(texture)
            doubleside_shader_material = createShaderMaterial(texture, { side: THREE.DoubleSide })
            manager = new CubesMeshBuilder(world, 1000, shader_material)
            manager_doubleside = new CubesMeshBuilder(world, 1000, doubleside_shader_material)
            manager_transparent = new CubesMeshBuilder(world, 1000, shader_material)
            generateChunk(0, 0)

            const block = blocks_palette.dirt
            for(let i = 2; i < 20; i++) {
                setBlock(0, DEFAULT_SPAWN_POS.x, DEFAULT_SPAWN_POS.y + i, DEFAULT_SPAWN_POS.z, block)
                setBlock(1, DEFAULT_SPAWN_POS.x, DEFAULT_SPAWN_POS.y + i, DEFAULT_SPAWN_POS.z, block)
            }

            // Обновляем меш
            manager.updateMesh()
            manager_transparent.updateMesh()
            manager_doubleside.updateMesh()
            // Добавляем меши в сцену
            scene.add(manager.mesh)
            scene.add(manager_transparent.mesh)
            scene.add(manager_doubleside.mesh)

            let memory_quads = (
                manager.getMemoryUsage() +
                manager_doubleside.getMemoryUsage() +
                manager_transparent.getMemoryUsage()
            ) / (1024 * 1024)

            let memory_worlds = (
                world.getMemoryUsage() +
                world_water.getMemoryUsage() +
                world_leaves.getMemoryUsage()
            ) / (1024 * 1024)

            console.log('Map:', world_size.x * chunk_size.x, 'x', world_size.z * chunk_size.z)
            console.log('Quads:', scene_info.quads.toLocaleString())
            console.log('Worlds:', memory_worlds.toFixed(2) + 'MB')
            console.log('Quads:', memory_quads.toFixed(2) + `MB, count: ${scene_info.quads.toLocaleString()}`)

            // Подключение stats.js
            stats = new Stats()
            stats.showPanel(0) // 0: FPS, 1: MS, 2: MB
            document.body.appendChild(stats.domElement)

            document.body.appendChild(renderer.domElement)
            addListeners()
            pnw1 = performance.now()
            animate()

        })

    </script>
</body>
</html>