<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Cube</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #87ceeb; }
        canvas { display: block; }
        .f3-line { margin-bottom: .2em; text-shadow: 0 0 10px #333; }
        .key { display: inline-block; border-radius: 4px; padding: .1em .5em; background-color:dimgrey; border: 2px solid #fff; }
        .coords { position: absolute; top: 10px; right: 10px; color: white; font-size: 16px; font-family: monospace; }
        #loading { position: absolute; color: white; font-weight: bold; text-shadow: 0 0 10px #333; z-index: -1; font-family: 'Courier New', Courier, monospace; left: 50%; top: 50%; transform: translate(-50%, -50%);}
    </style>
    <script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r110/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r110/examples/js/controls/PointerLockControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/simplex-noise@2.4.0/simplex-noise.min.js"></script>
</head>
<body>

    <div id="loading">Loading...</div>

    <script type="module">

        import Stats from 'https://cdnjs.cloudflare.com/ajax/libs/stats.js/r17/Stats.min.js'

        class PlayerController {

            constructor(world, gravity = 9.8, inertia = 0.99, start_position) {
                this.world = world
                this.gravity = gravity
                this.inertia = inertia
                this.position = new THREE.Vector3(start_position.x, start_position.y, start_position.z) // Текущая позиция игрока
                this.velocity = { x: 0, y: 0, z: 0 } // Скорость игрока
                this.isGrounded = false // Находится ли игрок на земле
                this.jumpForce = 5 // Сила прыжка
            }

            update(elapsed_ms) {
                const elapsed_seconds = elapsed_ms / 1000
                const margin = 0.2 // Минимальное расстояние до блока

                // Проверяем блок под игроком
                const block_below = this.world.getBlock(
                    this.position.x,
                    this.position.y - 0.5, // Слегка ниже текущей позиции
                    this.position.z
                )
                this.block_below = block_below

                // Устанавливаем флаг isGrounded
                this.isGrounded = !block_below?.passable

                // Применяем гравитацию
                if (!this.isGrounded) {
                    this.velocity.y -= this.gravity * elapsed_seconds
                }

                // Рассчитываем движение
                let moveVector = { x: 0, z: 0 }
                if (move_forward) {
                    const dir = new THREE.Vector3()
                    camera.getWorldDirection(dir)
                    moveVector.x += dir.x
                    moveVector.z += dir.z
                }
                if (move_backward) {
                    const dir = new THREE.Vector3()
                    camera.getWorldDirection(dir)
                    moveVector.x -= dir.x
                    moveVector.z -= dir.z
                }
                if (move_left) {
                    const right = new THREE.Vector3().crossVectors(new THREE.Vector3(0, 1, 0), camera.getWorldDirection(new THREE.Vector3())).normalize()
                    moveVector.x += right.x
                    moveVector.z += right.z
                }
                if (move_right) {
                    const right = new THREE.Vector3().crossVectors(new THREE.Vector3(0, 1, 0), camera.getWorldDirection(new THREE.Vector3())).normalize()
                    moveVector.x -= right.x
                    moveVector.z -= right.z
                }

                // Нормализуем движение для предотвращения ускорения при диагональном движении
                const length = Math.sqrt(moveVector.x ** 2 + moveVector.z ** 2)
                if (length > 0) {
                    moveVector.x /= length
                    moveVector.z /= length
                }

                // Применяем движение
                const movement_speed = 100
                this.velocity.x += moveVector.x * elapsed_seconds * movement_speed
                this.velocity.z += moveVector.z * elapsed_seconds * movement_speed

                // Применение инерции
                this.velocity.x *= this.inertia
                this.velocity.z *= this.inertia

                // Рассчитываем новую позицию
                let new_pos = new THREE.Vector3(
                    this.position.x + this.velocity.x * elapsed_seconds,
                    this.position.y + this.velocity.y * elapsed_seconds,
                    this.position.z + this.velocity.z * elapsed_seconds
                )

                // Проверяем столкновения с миром, учитывая margin
                const block_at_new_pos_x = this.world.getBlock(
                    new_pos.x + Math.sign(this.velocity.x) * margin, // Проверка с учетом направления
                    this.position.y,
                    this.position.z
                )

                if (!block_at_new_pos_x?.passable) {
                    // Блокируем движение по X
                    this.velocity.x = 0
                    new_pos.x = this.position.x
                }

                const block_at_new_pos_z = this.world.getBlock(
                    this.position.x,
                    this.position.y,
                    new_pos.z + Math.sign(this.velocity.z) * margin // Проверка с учетом направления
                )

                if (!block_at_new_pos_z?.passable) {
                    // Блокируем движение по Z
                    this.velocity.z = 0
                    new_pos.z = this.position.z
                }

                // Проверяем вертикальное столкновение
                const block_at_new_pos_y = this.world.getBlock(
                    this.position.x,
                    new_pos.y,
                    this.position.z
                )

                if (!block_at_new_pos_y?.passable) {
                    if (this.velocity.y < 0) {
                        this.isGrounded = true // Если падаем, то считаем, что игрок на земле
                    }
                    this.velocity.y = 0
                    new_pos.y = this.position.y
                }

                // Обновляем позицию
                this.position = new_pos
            }

            // Прыжок
            jump() {
                if (this.isGrounded) {
                    this.velocity.y = this.jumpForce
                    this.isGrounded = false
                }
            }

        }

        class VectorCollector {

            constructor() {
                this.list = new Map()
            }

            has(x, y, z) {
                return this.list.get(x)?.get(y)?.has(z) || false
            }

            set(x, y, z, value) {
                let xv = this.list.get(x)
                if(!xv) {
                    xv = new Map()
                    this.list.set(x, xv)
                }
                let yv = xv.get(y)
                if(!yv) {
                    yv = new Map()
                    xv.set(y, yv)
                }
                yv.set(z, value)
            }

            get(x, y, z) {
                return this.list.get(x)?.get(y)?.get(z) || null
            }

            values() {
                const that = this;
                return (function* () {
                    for (const x of that.list.values()) {
                        for (const y of x.values()) {
                            for (const value of y.values()) {
                                yield value
                            }
                        }
                    }
                })()
            }

        }

        class World {

            constructor(chunk_size, world_size_in_chunks) {
                this.chunk_size = chunk_size
                this.world_size_in_chunks = world_size_in_chunks
                this.world_size = {
                    x: this.world_size_in_chunks.x * this.chunk_size.x,
                    y: this.world_size_in_chunks.y * this.chunk_size.y,
                    z: this.world_size_in_chunks.z * this.chunk_size.z
                }
                this.chunks = new VectorCollector()
            }

            getMemoryUsage() {
                let memory_usage = 0
                for(const chunk of this.chunks.values()) {
                    memory_usage += chunk.getMemoryUsage()
                }
                return memory_usage
            }

            getChunkAddr(x, y, z) {
                return _ca.set(
                    Math.floor(x / this.chunk_size.x),
                    0, // Math.floor(y / this.chunk_size.y)
                    Math.floor(z / this.chunk_size.z),
                )
            }

            getChunk(x, y, z) {
                return this.chunks.get(x, y, z)
            }

            getBlock(x, y, z) {
                const chunk_addr = this.getChunkAddr(x, y, z)
                const chunk = this.getChunk(chunk_addr.x, chunk_addr.y, chunk_addr.z)
                return chunk ? chunk.getBlock(x - chunk.coord.x, y - chunk.coord.y, z - chunk.coord.z) : blocks_palette.air
            }

            getBlockID(x, y, z) {
                const chunk_addr = this.getChunkAddr(x, y, z)
                const chunk = this.getChunk(chunk_addr.x, chunk_addr.y, chunk_addr.z)
                return chunk ? chunk.getBlockID(x - chunk.coord.x, y - chunk.coord.y, z - chunk.coord.z) : 0
            }

        }

        class CubesMeshBuilder {

            constructor(chunk, world, shader_material) {
                this.chunk              = chunk
                this.world              = world
                this.reserved_polygons  = 0 // Начальный резерв кубов
                this.polygons_count     = 0 // Количество граней
                this.vertex_size        = 3 // Координаты x, y, z
                this.uvs_size           = 2 // Координаты x, y, z
                this.color_size         = 3 // Цветовые компоненты RGB
                this.flag_size          = 1 // Размер для кастомного флага
                this.resize_factor      = 1.5 // Коэффициент увеличения резервной памяти
                this.buffer             = new ArrayBuffer(0)
                this.vertices           = new Float32Array(this.buffer, 0, 0)
                this.uvs                = new Float32Array(this.buffer, 0, 0)
                this.colors             = new Float32Array(this.buffer, 0, 0)
                this.flags              = new Float32Array(this.buffer, 0, 0) // массив флагов
                this.used_polygons         = 0 // Количество добавленных кубов
                this.mesh               = new THREE.Mesh(new THREE.BufferGeometry(), shader_material)
                this.mesh.castShadow    = true
                this.mesh.receiveShadow = true
            }

            updateMesh() {
                const geometry = this.mesh.geometry
                const vpp = 3 // vertices per polygon
                const cnt = this.used_polygons * vpp
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(this.vertices.slice(0, cnt * this.vertex_size), this.vertex_size))
                geometry.setAttribute('uv', new THREE.Float32BufferAttribute(this.uvs.slice(0, cnt * this.uvs_size), this.uvs_size))
                geometry.setAttribute('color', new THREE.Float32BufferAttribute(this.colors.slice(0, cnt * this.color_size), this.color_size))
                geometry.setAttribute('flag', new THREE.Float32BufferAttribute(this.flags.slice(0, cnt * this.flag_size), this.flag_size))
                geometry.computeVertexNormals()
            }

            // 
            addPlant(x, y, z, block) {
                const face = block.faces[0]
                x += Math.random() * 0.2 - 0.1
                z += Math.random() * 0.2 - 0.1
                for(let i = 0; i < planting_offsets.length; i++) {
                    this.addFace(x, y, z, 0, face, planting_offsets[i])
                }
            }

            // Добавление куба в менеджер
            addCube(x, y, z, block, neighbours) {
                for (let i = 0; i < 6; i++) {
                    if (neighbours[i]) continue // Если грань не выбрана, пропускаем
                    const face = block.faces[i]
                    if(!face) continue
                    this.addFace(x, y, z, i, face, face_offsets[i])
                }
            }

            addFace(x, y, z, face_direction, face, face_offsets) {

                this._resizeBuffers(2)

                const hs  = 0.5
                const vpp = 3 // vertices per polygon
                const uv  = face.texture?.uv ?? empty_face
                const { chunk, colors, flags, uvs, vertices } = this
                const { vertices: face_vertices, uv: face_uv } = face_offsets
                const coord = chunk.coord

                let polygons_count = this.used_polygons
                let vi             = polygons_count * this.vertex_size * vpp
                let ui             = polygons_count * this.uvs_size * vpp
                let ci             = polygons_count * this.color_size * vpp
                let fi             = polygons_count * this.flag_size * vpp

                for (let i = 0; i < face_vertices.length; i += 3) {
                    vertices[vi++] = coord.x + x + hs * face_vertices[i] + 0.5
                    vertices[vi++] = coord.y + y + hs * face_vertices[i + 1] + 0.5
                    vertices[vi++] = coord.z + z + hs * face_vertices[i + 2] + 0.5
                    // Добавляем UV, масштабируя их по значениям u, v, u2, v2
                    uvs[ui++] = face_uv[(i / 3) * 2] === 0 ? uv[0] : uv[2]
                    uvs[ui++] = face_uv[(i / 3) * 2 + 1] === 0 ? uv[1] : uv[3]
                }

                // запись цветов и флагов
                const flag = face.flag || 0
                for(let p = 0; p < 6; p++) {
                    const ao_value = chunk.calculateAO(x, y, z, face_direction, p)
                    colors[ci++] = ao_value
                    colors[ci++] = ao_value
                    colors[ci++] = ao_value
                    flags[fi++] = flag
                }

                scene_info.quads++
                this.used_polygons += 2

            }

            // Увеличение памяти для буферов
            _resizeBuffers(add_count) {

                if (this.used_polygons + add_count < this.reserved_polygons) {
                    return
                }

                const polygons = this.reserved_polygons = Math.floor((this.reserved_polygons + 1000) * this.resize_factor)
                const total_count = polygons * (this.vertex_size + this.uvs_size + this.color_size + this.flag_size)

                const vpp = 3 // vertices per polygon

                const new_buffer = this.buffer = new ArrayBuffer(total_count * Float32Array.BYTES_PER_ELEMENT * vpp)
                const new_vertices = new Float32Array(new_buffer, 0, polygons * this.vertex_size * vpp)
                const new_uvs = new Float32Array(new_buffer, new_vertices.byteLength, polygons * this.uvs_size * vpp)
                const new_colors = new Float32Array(new_buffer, new_vertices.byteLength + new_uvs.byteLength, polygons * this.color_size * vpp)
                const new_flags = new Float32Array(new_buffer, new_vertices.byteLength + new_uvs.byteLength + new_colors.byteLength, polygons * this.flag_size * vpp)

                new_vertices.set(this.vertices)
                new_uvs.set(this.uvs)
                new_colors.set(this.colors)
                new_flags.set(this.flags)

                this.vertices = new_vertices
                this.uvs = new_uvs
                this.colors = new_colors
                this.flags = new_flags

            }

            getMemoryUsage() {
                return this.buffer.byteLength // * Float32Array.BYTES_PER_ELEMENT
            }

        }

        /**
         * Chunk
        */
        class Chunk {
            meshes = {
                regular: null,
                doubleside: null,
                transparent: null,
            }

            constructor(world, x, y, z, size, seed) {
                this.world = world
                this.size = size
                this.seed = seed
                this.addr = {x, y, z}
                this.coord = {x: x * size.x, y: y * size.y, z: z * size.z}
                this.blocks = new Uint8Array(size.x * size.y * size.z)
            }

            getMemoryUsage() {
                let memory_usage = this.blocks.byteLength
                for(const mesh of Object.values(this.meshes)) {
                    memory_usage += mesh?.getMemoryUsage() ?? 0
                }
                return memory_usage
            }

            getIndex(x, y, z) {
                return x + y * this.size.x + z * this.size.x * this.size.y
            }

            getBlock(x, y, z) {
                x = Math.floor(x)
                y = Math.floor(y)
                z = Math.floor(z)
                if (!this.isInBounds(x, y, z)) return null
                const index = this.getIndex(x, y, z)
                const block_id = this.blocks[index]
                return block_id ? block_by_id[block_id] : blocks_palette.air
            }

            getBlockID(x, y, z) {
                x = Math.floor(x)
                y = Math.floor(y)
                z = Math.floor(z)
                if (!this.isInBounds(x, y, z)) return 0
                const index = this.getIndex(x, y, z)
                return this.blocks[index]
            }

            setBlock(x, y, z, block) {
                x = Math.floor(x)
                y = Math.floor(y)
                z = Math.floor(z)
                if(!this.isInBounds(x, y, z)) return
                const index = this.getIndex(x, y, z)
                if(!block?.id) debugger
                this.blocks[index] = block.id
            }

            // Генератор
            generate() {

                const pn = performance.now()
                const { size, addr, coord } = this

                let iter = 0
                let n0 = 0
                let n2 = 0
                let ocean = 0
                let planing = 0

                const setBlock = this.setBlock.bind(this)

                function getXZNoise(x, z) {
                    const x2 = x + 1024
                    const z2 = z + 1024
                    n0 = simplex.noise2D(x / 2, z / 2)
                    const n1 = simplex.noise2D(x / 64, z / 64)
                    n2 = simplex.noise2D(x2 / 16, z2 / 16)
                    const n3 = simplex.noise2D(x2 / 8, z2 / 8)
                    return (n1 * 0.7 + n2 * 0.25 + n3 * 0.05)
                }

                function calcH(x, z) {
                    ocean = simplex.noise2D((x - 8192) / 384, (z - 8192) / 384)
                    planing = (simplex.noise2D((x - 1024) / 256, (z - 1024) / 256))
                    const height = getXZNoise(x, z) * (32 * ((planing + 1) / 2))
                    return Math.ceil (
                        (64 + ocean * 16) + (height < 0 ? height : height * 2)
                    )
                }

                function drawTree(x, y, z, random) {
                    const height = Math.ceil(random() * 8 + 2)
                    for(let yy = 0; yy < height; yy++) {
                        setBlock(x, y + yy, z, blocks_palette.oak_log)
                    }
                    // draw leaves
                    const radius = {xz: 3, y: 7}
                    const ax = x
                    const ay = y + height - 2
                    const az = z
                    for(let xx = -radius.xz; xx <= radius.xz; xx++) {
                        for(let yy = 0; yy <= radius.y; yy++) {
                            for(let zz = -radius.xz; zz <= radius.xz; zz++) {
                                if(xx * xx + yy * yy + zz * zz <= radius.xz * radius.xz) {
                                    if(xx == 0 && yy < 2 && zz == 0) continue
                                    setBlock(ax + xx, ay + yy, az + zz, blocks_palette.oak_leaves)
                                }
                            }
                        }
                    }
                }

                const random = pseudoRandom(addr.x * 256 + addr.z)

                for(let x = 0; x < size.x; x++) {
                    for(let z = 0; z < size.z; z++) {
                        const h = calcH(x + coord.x, z + coord.z)
                        for(let y = 0; y < 128; y++) {
                            if(y < h) {
                                let block = blocks_palette.stone
                                const y_from_top = h - y
                                if(y < 80 + n2 * (8 * planing)) {
                                    if(y == water_level - 1 && y == h - 1) {
                                        block = blocks_palette.sand
                                    } else if(y < n0 * 2 + 3) {
                                        block = blocks_palette.bedrock
                                    } else {
                                        if(y_from_top == 1 && y > water_level - 1) {
                                            block = blocks_palette.grass_block
                                            let gr = random()
                                            if(gr < .1) {
                                                gr /= .1
                                                const block = gr < .9 ? grasses[Math.floor((gr/.9) * grasses.length)] : plants[Math.floor(((gr-.9)/.1) * plants.length)]
                                                setBlock(x, y + 1, z, block)
                                            }
                                        } else if(y_from_top < 3) {
                                            block = y < water_level ? blocks_palette.gravel : blocks_palette.dirt
                                        }
                                    }
                                }
                                setBlock(x, y, z, block)
                            } else if(y < water_level && y >= h) {
                                setBlock(x, y, z, blocks_palette.water)
                            }
                        }
                        if(h > water_level && h < 75 && Math.round(random() * tree_chance) == 0) {
                            drawTree(x, h, z, random)
                        }
                    }
                }

            }

            isInBounds(x, y, z) {
                return x >= 0 && x < this.size.x &&
                    y >= 0 && y < this.size.y &&
                    z >= 0 && z < this.size.z
            }

            checkSolidNeighbours(x, y, z, neighbors, transparent) {
                const { coord, size } = this
                let cnt = 0
                for (let i = 0; i < 6; i++) {
                    const nx = x + directions[i].x
                    const ny = y + directions[i].y
                    const nz = z + directions[i].z
                    let block_id = 0
                    if(this.isInBounds(nx, ny, nz)) {
                        block_id = this.blocks[this.getIndex(nx, ny, nz)]
                    } else {
                        const chunk_addr = world.getChunkAddr(nx + coord.x, ny + coord.y, nz + coord.z)
                        const chunk = world.getChunk(chunk_addr.x, chunk_addr.y, chunk_addr.z)
                        if(chunk) {
                            const bx = (nx + chunk.coord.x + size.x) % size.x
                            const by = (ny + chunk.coord.y + size.y) % size.y
                            const bz = (nz + chunk.coord.z + size.z) % size.z
                            block_id = chunk.blocks[chunk.getIndex(bx, by, bz)]
                        }
                    }
                    if(!block_id) {
                        neighbors[i] = 0
                    } else {
                        const block = block_by_id[block_id]
                        neighbors[i] = (block.is_solid && (!block.transparent || transparent)) ? block.id : 0
                    }
                    cnt += neighbors[i] ? 1 : 0
                }
                return cnt !== 6
            }

            addMaterialMesh(material_name) {
                const mesh = this.meshes[material_name] = new CubesMeshBuilder(this, world, shader_materials[material_name])
                scene.add(mesh.mesh)
                return mesh
            }

            makeVertices() {
                const { blocks, size } = this
                let { doubleside, regular, transparent } = this.meshes
                for(let i = 0; i < blocks.length; i++) {
                    const block_id = blocks[i]
                    if(!block_id) continue
                    const block = block_by_id[block_id]
                    const x = i % size.x
                    const y = Math.floor(i / size.x) % size.y
                    const z = Math.floor(i / (size.x * size.y))
                    if(!block.is_solid || this.checkSolidNeighbours(x, y, z, neighbours_cache, block.transparent)) {
                        switch(block.style) {
                            case 'planting': {
                                doubleside ??= this.addMaterialMesh('doubleside')
                                doubleside.addPlant(x, y, z, block)
                                break
                            }
                            default: {
                                if(block.transparent) {
                                    transparent ??= this.addMaterialMesh('transparent')
                                    transparent.addCube(x, y, z, block, neighbours_cache)
                                } else {
                                    regular ??= this.addMaterialMesh('regular')
                                    regular.addCube(x, y, z, block, block.is_solid ? neighbours_cache : neighbours_empty)
                                }
                            }
                        }
                    }
                }
                this.update()
            }

            _getBlockID(x, y, z) {
                if(this.isInBounds(x, y, z)) {
                    return this.blocks[this.getIndex(x, y, z)]
                }
                const { coord, size } = this
                const chunk_addr = world.getChunkAddr(x + coord.x, y + coord.y, z + coord.z)
                const chunk = world.getChunk(chunk_addr.x, chunk_addr.y, chunk_addr.z)
                return chunk ? chunk.blocks[chunk.getIndex(
                    ((x + coord.x) % size.x + size.x) % size.x,
                    ((y + coord.y) % size.y + size.y) % size.y,
                    ((z + coord.z) % size.z + size.z) % size.z,
                )] : 0
            }

            _calcAO(x, y, z, ax, ay, az, fix) {
                let ao_value = 1
                let side1, side2
                let corner_block_id = this._getBlockID(x + ax, y + ay, z + az)
                switch(fix) {
                    case 0: {
                        side1 = this._getBlockID(x + ax, y + ay, z)
                        side2 = this._getBlockID(x + ax, y, z + az)
                        break
                    }
                    case 1: {
                        side1 = this._getBlockID(x + ax, y + ay, z)
                        side2 = this._getBlockID(x, y + ay, z + az)
                        break
                    }
                    case 2: {
                        side1 = this._getBlockID(x + ax, y, z + az)
                        side2 = this._getBlockID(x, y + ay, z + az)
                        break
                    }
                }
                const side1_block = side1 ? block_by_id[side1] : null
                const side2_block = side2 ? block_by_id[side2] : null
                const corner_block = corner_block_id ? block_by_id[corner_block_id] : null
                if(side1_block?.is_solid && !side1_block.transparent) ao_value -= 0.25
                if(side2_block?.is_solid && !side2_block.transparent) ao_value -= 0.25
                if(corner_block?.is_solid && !corner_block.transparent) ao_value -= 0.25
                return ao_value
            }

            calculateAO(x, y, z, i, p) {
                let ao_value = 1
                if(i != 1) {
                    const index = ao_indexes[p]
                    const a = ao_table[i]
                    const b = a.moves[index]
                    ao_value = this._calcAO(x, y, z, b[0], b[1], b[2], a.fix)
                }
                const ao_strenght = 0.8
                if(ao_value < 1 && ao_strenght != 1) {
                    ao_value *= ao_strenght
                }
                return ao_value
            }

            update() {
                for(const mesh of Object.values(this.meshes)) {
                    mesh?.updateMesh()
                }
            }

        }

        const textures = {
            dirt: {bin: 'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQBAMAAADt3eJSAAAAFVBMVEW5hVyHh4eWbEpsbGx0WER5VTpZPSnqDkA3AAAAbklEQVR42hXLwQnDQAwEwOVA7uDyNgq6AtJD/mLD6m0Muv5LCJ7/YES6OhNsvjLGhpXJtA1vW+nMQJy31o+Ncu4uJUwzDSQE13I5giyGGuxqCQTTxnX4RPDkJ+5ChZskgPp6HemIqwp8+ojp8voDZ2EdYwBe7AYAAAAASUVORK5CYII='},
            bedrock: {bin: 'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAAAAAA6mKC9AAAAcElEQVR42jWPMQ0DQBSFvpazgBgEPFHYbdKmCwth4AZgM0E8ttai9pDjwQNCzZ1tPlMAvEcAwmrjUFF4X3A190e8U/EnkXkrQVeruq8TmUC7LVY8qsE9FVy51TuBCQsAby2fwMPVbcI/An9zNdwD9wFD0lUf95ycGwAAAABJRU5ErkJggg=='},
            gravel: {bin: 'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQBAMAAADt3eJSAAAAGFBMVEWwrq6xoqKXl5eWjo6JgX6Bf39ya2lkW1tYVrIwAAAAe0lEQVR42g3GwRECIQwF0D/MWIENODtk7YC7DOFulqQANFCAsvXrOz18Uxd3MZBptVUydNZCbf+HueveFO9ncp3CWK+zUCBD/Wjo8VRsHKkNjYjkra6bo41gxMbwHKcY36ExXwaLwVjlkTZBmdIONULmMo4yM/zqyuz+A5MJJSnE6Mt8AAAAAElFTkSuQmCC'},
            oak_leaves: {bin: 'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQBAMAAADt3eJSAAAAD1BMVEUAAAC5vLmYmZh3dXdoZGjJX6haAAAAAXRSTlMAQObYZgAAAGlJREFUeNoFgAERwyAMAD8pAtJ0AgIYaAEBbI1/TTtSNOaPiyCHDqkwtVvIia7tHzB6p1IatFtW8gazuB93e1j7tBwy8PJtR4+OkW+0cDR2exThSqQeASMalo9QZe2iV8XcmbgRp5W8Rf/WMg1MmmHulQAAAABJRU5ErkJggg=='},
            oak_log: {bin: 'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQBAMAAADt3eJSAAAAElBMVEWYeEmRcUJ0WjZfSitMPSY4Kxj0FtFUAAAAaklEQVR42hXGQRHDMAwEQI1VBJINwLoTgLgEaiHohD+YOPtaoaXl3BBqas6C5DeVPBkgkOXSkVDQxKpT+8kqX2ZvbrvCYcJ/XHA3iV8sdLslJhI84UnLVvIJH5qxpJXRGSG2Y5D7TXXGxgPEiBE7ybf/RAAAAABJRU5ErkJggg=='},
            oak_log_top: {bin: 'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQBAMAAADt3eJSAAAAG1BMVEXCnWK4lF+vj1WfhE2WdEF+Yjd0WjZfSitMPSYsJcj4AAAAf0lEQVR42hXJsQ3CMBAF0H/OFxGNfZHoI8gqzMIMjMFCVGwAdQCxgO8EHZKP8NrHY0vhRY3rk8BG62n7aoHpQnzPKtEpxbcAXFksjZ6vQh8+D2StRA0pVjfEQvECFYinqtD0PbX6L2szIGCBBYJLdTsFcCPm4Z5TXbE/SHgp/gPG/zIQFSN2ggAAAABJRU5ErkJggg=='},
            stone: {bin: 'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAAAAAA6mKC9AAAAZElEQVR42jWNsQ0AMQjEGJcB3HsEr/xSkncBOgkfUyXIguoo4mEXGdkFFvBdlGmpwKCAWIWOeYFladCK4n2BXZZn6vR3dsXRfLnKWfFoXmtUrX81AiboaZ9u4I1G8KdqPICl6AdyLn2NfcJFIAAAAABJRU5ErkJggg=='},
            stone_bricks: {bin: 'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQBAMAAADt3eJSAAAAFVBMVEWcmZyLiYt/f394dnhqbWpjY2NaWVo/4AZ+AAAAbUlEQVR42hWJsREDIRDEuC3A7F7gmKMDXK5bIHFLXwHwDWBeo0AzAtOD3rhd8qqEnSUOEqZh29cTMZA1wb0iXy+iIeQNhKpqSBn923/9gCbnOhcXSWMh8jLavTaMeR4dCk97lQlZ4ic8IKlUSX8TNSDr6TM/jQAAAABJRU5ErkJggg=='},
            sand: {bin: 'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQBAMAAADt3eJSAAAAElBMVEXt68vn5Lvj27Daz6PVxJbRuopf1Q47AAAAZklEQVR42gVAwQ3CMBCzQPyRukEcBqjP/dNzWAC6/ywIm0y2GrH72h47eJ1VdqDpOdqF3FuqCK7BzApOv7N+Nlyx126E+nQYbKl1uCYOWcVLWMWMlSDdfnIJ5EtSBdKN5LdADrnIP0wTGY7btIheAAAAAElFTkSuQmCC'},
            grass_block_top: {bin: 'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAADAFBMVEU3Wx5IeCg2Wh4xUhs1WB0vTho0Vh06YSA3XB8zVRwyUxwyVBw+ZyIpRRc0Vx03XB47YiE4XR84Xh8vTxowUBo+aCI9ZiIzVhw8ZCEuTRkxURs1WR07YiBAaiMsSRhDcCUrSRg1WR4wURs/aiNAayNFciYrSBg/aSMuThosShgwTxo5XyA5YCBDbyUuTBk8ZSFCbiRDcSVHdictShktTBktSxk7YyFGdicAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEdUADQdjt2OxUAAAAAAAABAAAAAABzhKHtiHcAAE8AAAAAADAAAAAAAAAAAABzhPgAAHcAAAAAAAAAAAAAAAB0AAB2OxYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB4gBTQOHcAAIMAfQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGQAAADIAAAAh/UAADYAAAAQAAAANgCDs1jQOAC4AIMAh/V9AAAAAADEAAAAT+10PTau2XcAd3UAAAAAAAAAAAAAAAAAAAAAAADvRADOvYB2LAhP7mgJKQC3diwAAAAAAAAAAACewAB2LAkAAGAABQCAAAAAAAAQAIAAAMBwAAAAAAYAAAAAAwAAAAAAAAB6AHjQOACAAIMAT+4AAAAAAAA4AAAAg9AAAACzYAAAd3cAAAAAAAAAAAAAAAAAAAAAABgAAAAIAAAAT+4AAEAAAABYAAAAT+6o1rAAAAkMAH3zqL15AAAAAWJLR0SL8m9H4AAAAAlwSFlzAAALEwAACxMBAJqcGAAAAOFJREFUGNMNzMligjAUAMDHSwJkaSBhDUgR0ILBKhVr///P6nEuAxAgIZSFUcyFVB8akjA1NrM5K0oMQlFBrV0jZdvCQXXiM+vhSLgZrEM2akMr5aAeu3E6yen8lal5kRqsvZQ+TlaRyPHyNizXssWRs0Z8T4MyFKiIqvZ2b0wnPE1ZAWrt58l3123OkWC0gMl/dGjnTAxY6I16WCNT5r3Gx65GKt9H05HaNCgNhs+NOQ5n47kdyC8fuDuUuwGvjuisD16o1lSqE9Svx3ObAZckEUVU7UBiKe8WUP/diqaV0T9QvxT8vFJhIAAAAABJRU5ErkJggg=='},
            water_still: {bin: 'iVBORw0KGgoAAAANSUhEUgAAABAAAAIABAMAAAB5lPHgAAAAJ1BMVEX////5+fnY2NjW1tbV1dXT09PS0tLPz8/Ozs7CwsK4uLiurq6lpaUTLc7BAAAADXRSTlO0tLS0tLS0tLS0tLS0frXQ3wAABWRJREFUeNqN2D2OHLcSB/AC3pO8/XyCd4B3hHcE5+Ng1qY62UQCBpsosAwoE+AvbDZJD1BbSmXA2MTJGqD/dYOqQ3lYZH/M9IxsBgOCPWz+UF1kk00CN+DwHbkDcHcqP2BxUs8CBsihbm4gVwhEnQSl3Hb0TY9SZ6J0l3KWZ/Io5hR9MkDemqhdiUsAq5YWy/ReKePr/0IAegrP8OPKg5VHyN0E4k4YPd8Wj4bnZoe1ByuPn3k800PxbDoIhPrwPP8rPLb25PBg5VEAh442T3gKz4t0k5D7yWMUoVh4fOVB9dw1Ty6eBDdB/jeZQ+PPBnNIeHDJg/A4BL92tBf04dm9Onq4eczC49c9DjCa53D04MzzI5nntQeTx1cexmHhSdubHsNu8sRYduoxd1t7MITndjd5GPmH2QOYG48ehEeXHl14DsXjloiH4ukemwfNY9DZAzPTUpHqsaVnSNxnoaSeOeJjvPT0xWNLT36qHh095XkNk4dJjsBMQUduHr/msdnzGB7mYeH5YeFRjB6HhcfC05O5ifrSw8i9Ljw8enJj2KkHk2fOnz+b53A/e36ZPRnFcw+SMSH1gkfBZb4LcgqP8EvB/ujBZzxYemT05PBkPvbG0aP5lRQPhuphKZ4vc/XY6DFw8/jCg8mT00UPrniQV55N8zxvhb8gw3bp6U48Xj2+9GRswsPNw8Bh9gyN0Qa1uPPSA1z09EfPo/AN+egZiietPIAUz1P1ZMwehAcCDN1AcuaRhUcNWHu4q567h4gPnlmYyPH6Y3j2PdxeFY/OHm0eyMJze+7Ju+3oOZBe8xjhkifT++LB5Hkhpu602cFt+2KgvnoyqYcHlzwGwO235knV41c9DD3xqDuPnpt3zTMIb2fPvtOj5+eB7hcehEcnD4rnsCN4eLh5+M3Kg7/xWPNg8vxx9DyS5zE+xfP6w0BdeDKTX/EMqXp09ODo4aoYrnmw9txXD33FIC6exEyWO/HJ8+bt2qMrDxPcqqdHtL0k1s95PoVHTz198/xPQCz4/ZCkeXz0vHz7if5zydMSEgCDZfTk0fOmeSQvPK1QVtsK6kbIZk+WM89mJ5mMd6MHxbOlnz5G9g+zB3/reT15GsNOPRuGY/Ro9eCKJ4Wnzi96m5Yeg517ZPJY87gjb2fPetuD4pEzDwQYPQjPvnm4evZp9Ejx/DZ6ZOUZmMQNrj56kJoHuOjBXRo9duLx6lHKOPfE+vzhLdNPOnl89DjQ8plTnV8W45NUD1P+nMc2SVyj5YLn/1ASYH8b+SzNw6OnCw8zuauGx7wtsLNHDf/c47YRXPd81TxblmHhARwfvl96TKMfmfvoEU44JMrhMZAwoJB81RMM24dHTz3SPO+q55Bk6cnFQ++EduGRXPeHQHiiWjxpV9Znnj0MZEH12AUPSE88uc332fO+eNQGBn4tno/NY270AHqqM6XuD9tOODxGCqSE4X72gBlaPKgeu+Bxt9+XHg0PIE5uyHcPNT6PjLwpHjQPLL/sQBIKAVUEEB7U+HDaYehoACQ8zFtBCSbO4qMnnj9mDwuap1cyZL7rABJY5qNt9gBmeBEeg+XwYI4PEJ6cUvEcAIGbEPPt0mPNY2eeZ8C9eMwYzZPj/cV82zyQ8ACwEw8UwJnHJg+HZy+T5656tHqseVTJbfbkyYPJw1/W8852Fx4vnpuFR82x68885sWjkwfMxbOpHqZUPPOyPHqAk/j45MHs+dQVz2HHqXoMyF+QKYDqcUeq5/fxfKqTRyDT+rxdeF7zXb/0+Oq8HELo7GnU/Oboydh3LJNn+OXq95a1R714wNP3DQcT8SYtPHXQtce8emzyWKaH6oEAfwHoySkS2Hjk2AAAAABJRU5ErkJggg=='},
            short_grass: {bin: 'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQBAMAAADt3eJSAAAAFVBMVEUAAAC4t7igoKCRkZGDgYN2d3ZsbGyS5OzOAAAAAXRSTlMAQObYZgAAAG5JREFUeNptyDESgyAQheHHSvpt7DcDpCaGHMABqRnwBI73P4Ng7Wv+bx6eJgSmAVJguau0cC/eND6AK61dHeS/emCeXJwJEKNe4rhAFirWS4UlU4IsE3xsbTcx4Jda3Fzy0PWs+W8TwnEeOX+2CxhUDj0662krAAAAAElFTkSuQmCC'},
            dandelion: {bin: 'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAUklEQVQ4y2NgGAXDHfx/4/8fhMnW/O+a5f+Pc1VJNwSkAaZxb5YS2CCyDCFbMwyI17D8B2GyNHr1a/wPXa0Lpsm2HWYACJPlEpABZHsDBIixGQCyM01OrS9sngAAAABJRU5ErkJggg=='},
            oxeye_daisy: {bin: 'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAATlBMVEXr6+tR2/1vtE0nrPtXpDJVnzFRoStQmShVkzJRkTFBixxDhiPBQCM5fhYyeg4AAAD39/fW6Oj/7E/+1jn1uiebvb3xnSVVqy1Smi4XfASspZShAAAAEHRSTlMAAAAAAAAAAAAAAAAAAAAAHik/2wAAAGZJREFUeNptyFEOAiAMBNGqiCJWdgWE3v+ixsSkjXG+Jk/aT/IX5D7BkzgcSIDNgRi9czoA/TkAh8nRX6BDIkBmB6nETOJQz7dtSR308lhaItheSQO0YqvYNYDWZbkFyLojfLLjd97lCA7ioBDbWwAAAABJRU5ErkJggg=='},
        }

        const directions = [
            { x: 0, y: 1, z: 0 },   // Верх
            { x: 0, y: -1, z: 0 },  // Низ
            { x: 0, y: 0, z: 1 },   // Перед
            { x: 0, y: 0, z: -1 },  // Зад
            { x: -1, y: 0, z: 0 },  // Лево
            { x: 1, y: 0, z: 0 }    // Право
        ]

        const blocks_palette = {
            air: {id: 0, faces: [], passable: 1},
            dirt: {id: 1, faces: [
                {color: [0.4039, 0.2667, 0.1294], flag: 32, texture: textures.dirt}, // Верх — зеленый
                {color: [0.4039, 0.2667, 0.1294], flag: 32, texture: textures.dirt}, // Низ — коричневый
                {color: [0.4039, 0.2667, 0.1294], flag: 32, texture: textures.dirt}, // Перед — коричневый
                {color: [0.4039, 0.2667, 0.1294], flag: 32, texture: textures.dirt}, // Зад — коричневый
                {color: [0.4039, 0.2667, 0.1294], flag: 32, texture: textures.dirt}, // Лево — коричневый
                {color: [0.4039, 0.2667, 0.1294], flag: 32, texture: textures.dirt}, // Право — коричневый
            ], is_solid: true},
            grass_block: {id: 2, faces: [
                {color: [99/256, 127/256, 64/256], texture: textures.grass_block_top}, // Верх — зеленый
                {color: [0.4039, 0.2667, 0.1294], texture: textures.dirt}, // Низ — коричневый
                {color: [0.4039, 0.2667, 0.1294], flag: 2 | 32, texture: textures.dirt}, // Перед — коричневый
                {color: [0.4039, 0.2667, 0.1294], flag: 2 | 32, texture: textures.dirt}, // Зад — коричневый
                {color: [0.4039, 0.2667, 0.1294], flag: 2 | 32, texture: textures.dirt}, // Лево — коричневый
                {color: [0.4039, 0.2667, 0.1294], flag: 2 | 32, texture: textures.dirt}, // Право — коричневый
            ], is_solid: true},
            stone: {id: 3, faces: [
                {color: [0.5451, 0.5333, 0.5294], texture: textures.stone}, // Верх — светло-серый
                {color: [0.5451, 0.5333, 0.5294], texture: textures.stone}, // Низ — темно-серый
                {color: [0.5451, 0.5333, 0.5294], texture: textures.stone}, // Перед — темно-серый (с оттенком)
                {color: [0.5451, 0.5333, 0.5294], texture: textures.stone}, // Зад — темно-серый (с оттенком)
                {color: [0.5451, 0.5333, 0.5294], texture: textures.stone}, // Лево — темно-серый
                {color: [0.5451, 0.5333, 0.5294], texture: textures.stone}, // Право — темно-серый
            ], is_solid: true},
            water: {id: 4, faces: [
                {color: [63/256, 118/256, 228/256], flag: 1, texture: textures.water_still}, // Верх — синий
                null, // {color: [63/256, 118/256, 228/256], texture: textures.water_still}, // Низ — синий
                null, // {color: [63/256, 118/256, 228/256], texture: textures.water_still}, // Перед — синий
                null, // {color: [63/256, 118/256, 228/256], texture: textures.water_still}, // Зад — синий
                null, // {color: [63/256, 118/256, 228/256], texture: textures.water_still}, // Лево — синий
                null, // {color: [63/256, 118/256, 228/256], texture: textures.water_still}, // Право — синий
            ], is_solid: true, transparent: true, passable: 1},
            sand: {id: 5, faces: [
                {color: [0.8, 0.8, 0.6], texture: textures.sand}, // Верх — светло-коричневый
                {color: [0.8, 0.8, 0.6], texture: textures.sand}, // Низ — светло-коричневый
                {color: [0.8, 0.8, 0.6], texture: textures.sand}, // Перед — светло-коричневый
                {color: [0.8, 0.8, 0.6], texture: textures.sand}, // Зад — светло-коричневый
                {color: [0.8, 0.8, 0.6], texture: textures.sand}, // Лево — светло-коричневый
                {color: [0.8, 0.8, 0.6], texture: textures.sand}, // Право — светло-коричневый
            ], is_solid: true},
            oak_log: {id: 6, faces: [
                {color: [0.7, 0.7, 0.5], texture: textures.oak_log_top}, // Верх — коричневый
                {color: [0.7, 0.7, 0.5], texture: textures.oak_log_top}, // Низ — коричневый
                {color: [146/256, 108/256, 77/256], flag: 8, texture: textures.oak_log}, // Перед — коричневый
                {color: [146/256, 108/256, 77/256], flag: 8, texture: textures.oak_log}, // Зад — коричневый
                {color: [146/256, 108/256, 77/256], flag: 8, texture: textures.oak_log}, // Лево — коричневый
                {color: [146/256, 108/256, 77/256], flag: 8, texture: textures.oak_log}, // Право — коричневый
            ], is_solid: true},
            oak_leaves: {id: 7, faces: [
                {color: [0.0, 0.6, 0.0], flag: 16, texture: textures.oak_leaves}, // Верх — зеленый
                {color: [0.0, 0.6, 0.0], flag: 16, texture: textures.oak_leaves}, // Низ — зеленый
                {color: [0.0, 0.6, 0.0], flag: 16, texture: textures.oak_leaves}, // Перед — зеленый
                {color: [0.0, 0.6, 0.0], flag: 16, texture: textures.oak_leaves}, // Зад — зеленый
                {color: [0.0, 0.6, 0.0], flag: 16, texture: textures.oak_leaves}, // Лево — зеленый
                {color: [0.0, 0.6, 0.0], flag: 16, texture: textures.oak_leaves}, // Право — зеленый
            ]},
            bedrock: {id: 8, faces: [
                {color: [0.1, 0.1, 0.1], texture: textures.bedrock}, // Верх — черный
                {color: [0.1, 0.1, 0.1], texture: textures.bedrock}, // Низ — черный
                {color: [0.1, 0.1, 0.1], texture: textures.bedrock}, // Перед — черный
                {color: [0.1, 0.1, 0.1], texture: textures.bedrock}, // Зад — черный
                {color: [0.1, 0.1, 0.1], texture: textures.bedrock}, // Лево — черный
                {color: [0.1, 0.1, 0.1], texture: textures.bedrock}, // Право — черный
            ], is_solid: true},
            gravel: {id: 9, faces: [
                {color: [0.5, 0.5, 0.5], flag: 4, texture: textures.gravel}, // Верх — серый
                {color: [0.5, 0.5, 0.5], flag: 4, texture: textures.gravel}, // Низ — серый
                {color: [0.5, 0.5, 0.5], flag: 4, texture: textures.gravel}, // Перед — серый
                {color: [0.5, 0.5, 0.5], flag: 4, texture: textures.gravel}, // Зад — серый
                {color: [0.5, 0.5, 0.5], flag: 4, texture: textures.gravel}, // Лево — серый
                {color: [0.5, 0.5, 0.5], flag: 4, texture: textures.gravel}, // Право — серый
            ], is_solid: true},
            short_grass: {id: 10, faces: [
                {color: [1, 1, 1], flag: 128 | 64, texture: textures.short_grass},
            ], style: 'planting', passable: 1},
            dandelion: {id: 11, faces: [
                {color: [1, 1, 1], flag: 128, texture: textures.dandelion},
            ], style: 'planting', passable: 1},
            oxeye_daisy: {id: 12, faces: [
                {color: [1, 1, 1], flag: 128, texture: textures.oxeye_daisy},
            ], style: 'planting', passable: 1},
        }

        const block_by_id = new Array(256)
        for(const block of Object.values(blocks_palette)) {
            block_by_id[block.id] = block
        }

        const face_offsets = [
            { vertices: [-1, 1, -1, -1, 1, 1, 1, 1, 1, -1, 1, -1, 1, 1, 1, 1, 1, -1], uv: [0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0] }, // Верх
            { vertices: [-1, -1, 1, -1, -1, -1, 1, -1, -1, -1, -1, 1, 1, -1, -1, 1, -1, 1], uv: [0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1] }, // Низ
            { vertices: [-1, -1, 1, 1, -1, 1, 1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1], uv: [0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1] }, // Перед
            { vertices: [-1, -1, -1, -1, 1, -1, 1, 1, -1, -1, -1, -1, 1, 1, -1, 1, -1, -1], uv: [0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0] }, // Зад
            { vertices: [-1, -1, -1, -1, -1, 1, -1, 1, 1, -1, -1, -1, -1, 1, 1, -1, 1, -1], uv: [1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1] }, // Лево
            { vertices: [1, -1, -1, 1, 1, -1, 1, 1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1], uv: [0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0] }, // Право
        ]

        const grass_scale = 0.8

        const planting_offsets = [
            // Первая плоскость (диагональная, XZ)
            {vertices: [
                -1 * grass_scale, -1, -1 * grass_scale,
                1 * grass_scale, -1, 1 * grass_scale,
                1 * grass_scale, -1 + grass_scale * 2, 1 * grass_scale,
                -1 * grass_scale, -1, -1 * grass_scale,
                1 * grass_scale, -1 + grass_scale * 2, 1 * grass_scale,
                -1 * grass_scale, -1 + grass_scale * 2, -1 * grass_scale,
            ], uv: [0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0]},
            // Вторая плоскость (диагональная, XZ)
            {vertices: [
                -1 * grass_scale, -1,  1 * grass_scale,
                1 * grass_scale, -1, -1 * grass_scale,
                1 * grass_scale, -1 + grass_scale * 2, -1 * grass_scale,
                -1 * grass_scale, -1,  1 * grass_scale,
                1 * grass_scale, -1 + grass_scale * 2, -1 * grass_scale,
                -1 * grass_scale, -1 + grass_scale * 2,  1 * grass_scale,
            ], uv: [0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0]},
        ]

        const grasses = [blocks_palette.short_grass]
        const plants = [
            blocks_palette.dandelion,
            blocks_palette.oxeye_daisy,
            // poppy, blue_orchid, allium, azure_bluet, red_tulip, orange_tulip, white_tulip, pink_tulip, cornflower, lily_of_the_valley, sweet_berry_bush
        ]

        const ao_indexes = [0, 1, 2, 0, 2, 3]
        const ao_table = [
            {fix: 1, moves: [ [-1, 1, -1], [-1, 1, 1], [1, 1, 1], [1, 1, -1]] },
            null, // {fix: 1, moves: [ [1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1]] },
            {fix: 2, moves: [ [-1, -1, 1], [1, -1, 1], [1, 1, 1], [-1, 1, 1]] },
            {fix: 2, moves: [ [-1, -1, -1], [-1, 1, -1], [1, 1, -1], [1, -1, -1]] },
            {fix: 0, moves: [ [-1, -1, -1], [-1, -1, 1], [-1, 1, 1], [-1, 1, -1]] },
            {fix: 0, moves: [ [1, -1, -1], [1, 1, -1], [1, 1, 1], [1, -1, 1]] },
        ]

        let bob_зarams = {
            time: 0,              // Время для bobview
            frequency: 8,         // Частота покачивания
            amplitudeX: 0.05,     // Горизонтальная амплитуда
            amplitudeY: 0.1,      // Вертикальная амплитуда
            amplitude: 0.1,       // Вертикальная амплитуда
        }

        const seed             = 'seed' 
        const player_height     = 1.8
        const fog_color         = 0x87CEEB // Цвет ясного неба в Minecraft
        const pnw               = performance.now()
        const world_size        = {x: 8, y: 1, z: 8}
        const chunk_size        = {x: 24, y: 128, z: 24}
        const DEFAULT_SPAWN_POS = {x: (world_size.x * chunk_size.x) / 2, y: 120, z: (world_size.z * chunk_size.z) / 2}
        const scene_info        = { quads: 0 }
        const saved_pos         = localStorage.getItem('player_position')
        const init_pos          = saved_pos ? JSON.parse(saved_pos) : DEFAULT_SPAWN_POS
        const simplex           = new SimplexNoise('1')
        const world             = new World(chunk_size, world_size)
        const player_controller = new PlayerController(world, 9.8, 0.9, init_pos)
        const velocity          = new THREE.Vector3()
        const direction         = new THREE.Vector3()
        const _ca               = new THREE.Vector3()
        const up                = new THREE.Vector3(0, 1, 0)
        const neighbours_cache  = [0, 0, 0, 0, 0, 0]
        const neighbours_empty  = [0, 0, 0, 0, 0, 0]
        const empty_face        = [0, 0, 0, 0]
        const water_level       = 64
        const tree_chance       = 64

        let stats
        let beft = 1
        let spectator_mode = localStorage.getItem('spectator_mode') === 'true'
        let move_forward = false, move_backward = false, move_left = false, move_right = false
        let move_up = false, move_down = false
        let speed_mul = 1
        let pnw1
        let shader_materials

        // 
        const scene = new THREE.Scene()
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000)
        const renderer = new THREE.WebGLRenderer({ antialias: false, precision: 'highp' })
        renderer.setPixelRatio(window.devicePixelRatio) // Настраиваем разрешение канваса
        renderer.setSize(window.innerWidth, window.innerHeight) // Устанавливаем размер
        scene.background = new THREE.Color(fog_color) // Устанавливаем фон
        camera.position.set(init_pos.x, init_pos.y, init_pos.z)
        const controls = new THREE.PointerLockControls(camera, document.body)

        const saved_dir = localStorage.getItem('direction')
        saved_dir && camera.lookAt(...direction.copy(JSON.parse(saved_dir)).toArray())

        // Создаем элемент для отображения координат
        const coords_el = document.createElement('div')
        coords_el.classList.add('coords')
        document.body.appendChild(coords_el)

        function addListeners() {

            document.body.addEventListener('click', () => controls.lock())

            // on mouse wheel
            document.addEventListener('wheel', (event) => {
                speed_mul *= event.deltaY < 0 ? 1.1 : 0.9
            })

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight
                camera.updateProjectionMatrix()
                renderer.setSize(window.innerWidth, window.innerHeight)
            })

            const handleKeyEvent = (event, is_key_down) => {
                const key_state = is_key_down;
                switch (event.code) {
                    case 'KeyW': move_forward = key_state; break
                    case 'KeyS': move_backward = key_state; break
                    case 'KeyA': move_left = key_state; break
                    case 'KeyD': move_right = key_state; break
                    case 'ShiftLeft': move_down = key_state; break
                    case 'Space': 
                        if (key_state) player_controller.jump()
                        move_up = key_state
                        break
                    case 'F4':
                        if (!key_state) {
                            const pos = {...(spectator_mode ? controls.getObject().position : player_controller.position)}
                            localStorage.setItem('player_position', JSON.stringify(pos))
                            localStorage.setItem('spectator_mode', spectator_mode)
                            localStorage.setItem('direction', JSON.stringify(direction))
                        }
                        break
                    case 'KeyR':
                        if (!key_state) {
                            let pos = localStorage.getItem('player_position')
                            teleportTo(pos ? JSON.parse(pos) : DEFAULT_SPAWN_POS)
                        }
                        break
                    case 'F8':
                        if (key_state) teleportRandomly()
                        break;
                    case 'KeyG':
                        if (!key_state) {
                            spectator_mode = !spectator_mode
                            teleportTo({...(spectator_mode ? player_controller.position : controls.getObject().position)})
                            event.preventDefault()
                            event.stopPropagation()
                        }
                        break
                }
            };

            document.addEventListener('keydown', (event) => handleKeyEvent(event, true))
            document.addEventListener('keyup', (event) => handleKeyEvent(event, false))

        }

        function createShaderMaterial(texture, options = {}) {
            texture.minFilter = THREE.NearestFilter // Для уменьшения
            texture.magFilter = THREE.NearestFilter // Для увеличения
            texture.needsUpdate = true // Обновляем текстуру
            return new THREE.ShaderMaterial({
                vertexColors: true,
                side: THREE.FrontSide,
                ...options,
                uniforms: THREE.UniformsUtils.merge([
                    THREE.UniformsLib.lights, // Подключаем освещение и шедоумапы
                    {
                        cameraPosition: { value: new THREE.Vector3() }, // Передаем позицию камеры
                        cameraOffset: { value: new THREE.Vector3() }, // Передаем позицию камеры
                        fogColor: { value: new THREE.Color(0x87CEEB) }, // Цвет тумана
                        fogNear: { value: 100.0 }, // Начало тумана
                        time: { value: 0.0 }, // текущее время
                        in_water: { value: 0.0 }, // текущее время
                        fogFar: { value: world_size.x * chunk_size.x * 2 }, // Конец тумана
                        texture: { value: texture }, // передача текстуры
                    }
                ]),
                vertexShader: `
                    precision highp float;

                    varying vec3 vColor;
                    varying vec3 vWorldPosition;
                    varying vec4 vShadowCoord;
                    varying vec2 vUv; // Передаём UV во фрагментный шейдер
                    attribute float flag;
                    varying float vFlag;
                    uniform float time;
                    uniform float in_water;
                    varying float vTime;
                    varying float vInWater;
                    uniform vec3 cameraOffset; // Смещение камеры

                    varying vec3 vNormal;

                    #include <common>
                    #include <shadowmap_pars_vertex> // Подключаем расчеты для шедоумап

                    bool checkFlag(int bit) {
                        float rounded = floor(vFlag + 0.5); // Округляем значение
                        float divisor = float(bit);
                        return mod(floor(rounded / divisor), 2.0) >= 1.0; // Проверяем, установлен ли бит
                    }

                    void main() {
                        vUv = uv;
                        vTime = time;
                        vInWater = in_water;
                        vFlag = flag; // Передаем во фрагментный шейдер
                        vColor = color;
                        vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                        vWorldPosition = worldPosition.xyz;
                        vNormal = normal; // Передаём нормаль во фрагментный шейдер

                        // Вычисляем координаты для шедоумапы
                        #include <worldpos_vertex>
                        #include <shadowmap_vertex>

                        // waves
                        vec3 modifiedPosition = position;
                        if (checkFlag(1)) {
                            // волны воды
                            modifiedPosition.y -= 2./16.;
                            modifiedPosition.y += sin(position.x * 2.0 + time * 2.) * 0.0625;
                            modifiedPosition.y += cos(position.z * 2.0 + time * 2.) * 0.0625;
                        } else if (checkFlag(16)) {
                            // листва
                            modifiedPosition.x += sin(position.x * 2.0 + time * 2.) * 0.0625;
                            modifiedPosition.x += cos(position.z * 2.0 + time * 2.) * 0.0625;
                            modifiedPosition.z += sin(position.x * 2.0 + time * 2.) * 0.0625;
                            modifiedPosition.z += cos(position.z * 2.0 + time * 2.) * 0.0625;
                        }

                        gl_Position = projectionMatrix * modelViewMatrix * vec4(modifiedPosition - cameraOffset, 1.0);
                    }
                `,
                fragmentShader: `
                    precision highp float;
                    #extension GL_OES_standard_derivatives : enable
                    uniform sampler2D map; // Добавьте текстуру
                    varying vec2 vUv; // Принимаем UV из вершины
                    varying float vTime;
                    varying float vInWater;

                    varying vec3 vColor;
                    varying vec3 vWorldPosition;
                    varying vec4 vShadowCoord;
                    varying float vFlag;
                    varying vec3 vNormal; // Получаем нормаль из вершинного шейдера

                    uniform vec3 fogColor;       // Цвет тумана
                    uniform float fogNear;       // Начало тумана
                    uniform float fogFar;        // Конец тумана

                    uniform sampler2D texture; // Передаём текстуру в шейдер

                    const int FLAG_WATER_ANIMATED = 1;
                    const int FLAG_GRASS_BLOCK_SIDE = 2;
                    // const int UNUSED_FLAG_GRAVEL = 4;
                    // const int FLAG_ = 8;
                    const int FLAS_ANIMATED_LEAVES = 16;
                    const int FLAG_NO_CAN_TAKE_AO = 128;
                    const int FLAG_GRASS_COLOR = 64;

                    float hash(vec3 p) {
                        p = fract(p * 0.1031);
                        p += dot(p, p.yzx + 19.19);
                        return fract((p.x + p.y) * p.z);
                    }

                    bool checkFlag(int bit) {
                        float rounded = floor(vFlag + 0.5); // Округляем значение
                        float divisor = float(bit);
                        return mod(floor(rounded / divisor), 2.0) >= 1.0; // Проверяем, установлен ли бит
                    }

                    void main() {

                        vec3 grass_color = vec3(84./256., 147./256., 42./256.);
                        vec3 water_color = vec3(15./256., 94./256., 156./256.);

                        // Расчет тени
                        float shadow = 1.0;
                        #if NUM_DIR_LIGHTS > 0
                            shadow = texture2DShadow(shadowMap[0], vShadowCoord.xyz);
                        #endif

                        float scale = 16.0;
                        vec3 pp = vWorldPosition;
                        if(checkFlag(8)) {
                            pp.y /= 2.0;
                        }
                        vec3 quantizedPos = floor(pp * scale + 1e-3); // Добавлен эпсилон
                        float randomness = hash(quantizedPos);
                        vec3 finalColor = vColor;

                        vec2 uv = vUv;

                        if (checkFlag(FLAG_WATER_ANIMATED)) {
                            float frame_count = 32.0;
                            float frame_height = 1.0 / frame_count;
                            float current_frame = mod(floor(vTime * 16.), frame_count);
                            uv.y = uv.y - frame_height * current_frame;
                        }

                        vec4 texColor = texture2D(texture, uv);

                        if(texColor.a < 0.1) {
                            discard;
                        }

                        if(checkFlag(FLAS_ANIMATED_LEAVES)) {
                            texColor.rgb *= grass_color;
                        }
                        if(checkFlag(FLAG_WATER_ANIMATED)) {
                            texColor.rgb *= water_color;
                        }
                        if(checkFlag(FLAG_GRASS_COLOR)) {
                            texColor.rgb *= grass_color;
                        }

                        finalColor = texColor.rgb;

                        if(vInWater > 0.0) {
                            finalColor = mix(finalColor, water_color, 0.25);
                        }

                        if (checkFlag(FLAG_GRASS_BLOCK_SIDE)) {
                            // шапка травы
                            float quadY = mod(vWorldPosition.y, 1.0);
                            float rr = vec3(randomness).y * 0.2;
                            if (quadY > floor((0.7 + rr) * 16.) / 16.) {
                                // Изменяем цвет для верхней части квада
                                finalColor = grass_color; // Красный цвет, например
                                vec3 colorDeviation = vec3(randomness) * 0.2 - 0.1;
                                finalColor = clamp(finalColor + colorDeviation, 0.0, 1.0) * shadow;
                            }
                        }

                        finalColor *= vColor;

                        if(checkFlag(FLAG_NO_CAN_TAKE_AO)) {
                            finalColor *= 1.2; // Осветлить верх
                        } else {
                            // Вычисляем нормаль на основе позиции
                            vec3 normal = normalize(vNormal); // Нормализуем перед использованием
                            // Применяем изменение цвета в зависимости от нормали
                            if (normal.y > 0.5) {
                                finalColor *= 1.2; // Осветлить верх
                            } else if (normal.y < -0.5) {
                                finalColor *= 0.5; // Затемнить низ
                            } else if (normal.z < 0.0) {
                                finalColor *= 0.7; // Затемнить север
                            } else if (normal.z > 0.0) {
                                finalColor *= 0.7; // Осветлить юг
                            } else {
                                finalColor *= 0.9; // Остальные случаи
                            }
                        }

                        // Рассчитываем расстояние до камеры
                        float distanceToCamera = length(vWorldPosition - cameraPosition);

                        distanceToCamera *= vInWater > 0.0 ? 12.0 : 1.0;

                        // Применяем туман
                        float fogFactor = smoothstep(fogNear, fogFar, distanceToCamera);
                        vec3 foggedColor = mix(finalColor, vInWater > 0.0 ? water_color : fogColor, fogFactor);

                        float alpha = checkFlag(1) ? 0.75 : 1.0;
                        gl_FragColor = vec4(foggedColor, alpha);
                    }
                `
            })

        }

        async function createTexture() {
            const canvas = document.createElement('canvas')
            const ctx = canvas.getContext('2d')
            const keys = Object.keys(textures)
            // Загружаем все текстуры и определяем их размеры
            const images = await Promise.all(keys.map(key => {
                const img = new Image()
                img.src = 'data:image/png;base64,' + textures[key].bin
                return new Promise(resolve => {
                    img.onload = () => resolve({ key, img, width: img.width, height: img.height })
                })
            }))
            // Определяем сторону атласа как ближайшую степень двойки от самой длинной стороны текстур
            const max_side = Math.max(...images.map(img => Math.max(img.width, img.height)))
            const atlas_size = Math.pow(2, Math.ceil(Math.log2(max_side)))
            canvas.width = atlas_size
            canvas.height = atlas_size
            // Размещаем текстуры в атласе
            let x_offset = 0
            let y_offset = 0
            let row_height = 0
            images.forEach(img => {
                if (x_offset + img.width > atlas_size) {
                    x_offset = 0
                    y_offset += row_height
                    row_height = 0
                }
                if (y_offset + img.height > atlas_size) {
                    throw new Error('Не удалось разместить все текстуры в атласе. Увеличьте размер атласа.')
                }
                ctx.drawImage(img.img, x_offset, y_offset, img.width, img.height)
                // Сохраняем UV-координаты
                textures[img.key].uv = [
                    x_offset / atlas_size,
                    1 - y_offset / atlas_size,
                    (x_offset + img.width) / atlas_size,
                    1 - (y_offset + img.width) / atlas_size
                ]
                x_offset += img.width
                row_height = Math.max(row_height, img.height)
            })
            // function downloadCanvas(canvas, filename = 'atlas.png') {
            //     const link = document.createElement('a')
            //     link.download = filename
            //     link.href = canvas.toDataURL('image/png')
            //     link.click()
            // }
            // downloadCanvas(canvas, 'texture-atlas.png')
            return new THREE.CanvasTexture(canvas)
        }

        // Функция для обновления координат
        function updateCoordinates(x, y, z) {
            if(Math.random() < 0.9) return
            coords_el.innerHTML = `<div class="f3-line">${x.toFixed(1)}, ${y.toFixed(1)}, ${z.toFixed(1)}</div>
            <div class="f3-line"><strong class="key">G</strong> gamemode: ${player_controller.gamemode ? 'creative' : 'survival'}</div>
            <div class="f3-line"><strong class="key">F8</strong> random teleport</div>
            <div class="f3-line"><strong class="key">F4</strong> set home</div>
            <div class="f3-line"><strong class="key">F6</strong> return to home</div>`
        }

        function pseudoRandom(seed) {
            let value = (seed < 0 ? seed + 2147483647 : seed) % 2147483647
            return function() {
                value = (value * 16807) % 2147483647
                return value / 2147483647
            }
        }

        // 
        function applyBobView(position, elapsed_time) {
            const is_moving = move_forward || move_backward || move_left || move_right
            if(!player_controller.isGrounded) {
                elapsed_time = 0
            }
            const { frequency, amplitudeX, amplitudeY } = bob_зarams
            // Если игрок движется, увеличиваем время
            if (is_moving) {
                beft = 1
            } else {
                beft *= 0.9
            }
            bob_зarams.time += elapsed_time * 0.001 * beft
            // Смещение по Y (резкое вертикальное качание)
            const offset_y = Math.abs(Math.sin(bob_зarams.time * frequency)) * amplitudeY
            // Смещение по X (плавное горизонтальное качание)
            const offset_x = Math.sin(bob_зarams.time * frequency * 0.5) * amplitudeX
            return new THREE.Vector3(
                position.x + offset_x,
                position.y - offset_y,
                position.z
            )
        }

        function teleportTo(pos) {
            if (spectator_mode) {
                controls.getObject().position.set(pos.x, pos.y, pos.z)
            } else {
                player_controller.position.set(pos.x, pos.y, pos.z)
                player_controller.velocity.y = 0
            }
        }

        function teleportRandomly() {
            const range = init_pos.x * 0.8 // диапазон координат для телепортации
            teleportTo(new THREE.Vector3(
                Math.round(init_pos.x + Math.random() * range - range / 2) + 0.5,
                Math.round(init_pos.y + Math.random() * 16), // чтобы не улетать слишком высоко
                Math.round(init_pos.z + Math.random() * range - range / 2) + 0.5,
            ))
        }

        // Функция анимации
        function animate() {

            pnw1 ??= performance.now()
            stats.begin() // Начало замера

            requestAnimationFrame(animate)

            const elapsed = performance.now() - pnw1
            const player_xyz = spectator_mode ? controls.getObject().position : player_controller.position
            const chunk_addr = world.getChunkAddr(player_xyz.x, player_xyz.y, player_xyz.z)

            if(!world.chunks.has(chunk_addr.x, chunk_addr.y, chunk_addr.z)) {
                let p = performance.now()
                const chunk = generateChunk(chunk_addr.x, chunk_addr.y, chunk_addr.z)
                p = performance.now() - p
                world.chunks.set(chunk_addr.x, chunk_addr.y, chunk_addr.z, chunk)
                let p2 = performance.now()
                chunk.makeVertices()
                console.log('Chunk generated in', p.toFixed(2) + 'ms, vertices in', (performance.now() - p2).toFixed(2) + 'ms')
            }

            if(spectator_mode) {

                const speed = 0.025 * speed_mul
                velocity.x *= 0.95
                velocity.y *= 0.95
                velocity.z *= 0.95

                if (move_forward) velocity.z += speed
                if (move_backward) velocity.z -= speed
                if (move_left) velocity.x += speed
                if (move_right) velocity.x -= speed
                if (move_up) velocity.y += speed
                if (move_down) velocity.y -= speed

                // Рассчитываем направление движения относительно камеры
                direction.set(0, 0, 0)
                camera.getWorldDirection(direction)
                direction.y = 0 // Движение только по горизонтали
                direction.normalize()

                const right = new THREE.Vector3().crossVectors(up, direction).normalize()
                const move = new THREE.Vector3()
                move.addScaledVector(direction, velocity.z)
                move.addScaledVector(right, velocity.x)
                move.y += velocity.y

                controls.getObject().position.add(move)

                // Обновляем панель с координатами
                const camera_pos = camera.position // Используйте ваши координаты
                updateCoordinates(camera_pos.x, camera_pos.y, camera_pos.z)

            } else {

                player_controller.update(elapsed)

                // Обновление позиции камеры
                const player_pos = player_controller.position
                const camera_pos = applyBobView(player_pos, elapsed)
                controls.getObject().position.set(camera_pos.x, camera_pos.y, camera_pos.z)

                // Обновляем панель с координатами
                updateCoordinates(player_pos.x, player_pos.y, player_pos.z)

            }

            const eye_block_pos = camera.position.clone()
            eye_block_pos.y += player_height
            const block_in_camera = world.getBlock(...eye_block_pos.toArray())

            for(const mat of Object.values(shader_materials)) {
                mat.uniforms.cameraPosition.value.copy({x: camera.position.x, y: camera.position.y, z: camera.position.z})
                mat.uniforms.time.value = performance.now() / 1000
                mat.uniforms.in_water.value = block_in_camera?.id == 4 ? 1 : 0
                mat.uniforms.cameraOffset.value.y = player_height
            }

            renderer.render(scene, camera)
            stats.end() // Конец замера
            pnw1 = performance.now()

        }

        function generateChunk(x, y, z) {
            const chunk = new Chunk(world, x, y, z, chunk_size, seed)
            chunk.generate()
            return chunk
        }

        createTexture().then(texture => {

            shader_materials = {
                regular: createShaderMaterial(texture),
                transparent: createShaderMaterial(texture, { side: THREE.DoubleSide, transparent: true}),
                doubleside: createShaderMaterial(texture, { side: THREE.DoubleSide }),
            }

            let p = performance.now()
            for(let x = 0; x < world_size.x; x++) {
                for(let z = 0; z < world_size.z; z++) {
                    const chunk = generateChunk(x, 0, z)
                    world.chunks.set(x, 0, z, chunk)
                }
            }
            Array.from(world.chunks.values()).map(chunk => chunk.makeVertices())

            console.log(`${world_size.x * world_size.z} chunks generated in`, (performance.now() - p).toFixed(2) + 'ms')
            console.log('Map:', world_size.x * chunk_size.x, 'x', world_size.z * chunk_size.z)
            console.log('Quads:', scene_info.quads.toLocaleString())
            console.log('Memory usage:', (world.getMemoryUsage() / (1024 * 1024)).toFixed(2) + 'MB')

            // Подключение stats.js
            stats = new Stats()
            stats.showPanel(0) // 0: FPS, 1: MS, 2: MB
            document.body.appendChild(stats.domElement)

            document.body.appendChild(renderer.domElement)

            addListeners()
            animate()

        })

    </script>
</body>
</html>